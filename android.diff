diff -Nru src_93/blkdev_cdimage.cpp src/blkdev_cdimage.cpp
--- src_93/blkdev_cdimage.cpp	2019-08-10 17:34:48.000000000 +0300
+++ src/blkdev_cdimage.cpp	2019-08-10 17:37:32.252039526 +0300
@@ -13,7 +13,9 @@
 */
 #include "sysdeps.h"
 
+#ifdef HAVE_SYS_TIMEB_H
 #include <sys/timeb.h>
+#endif
 
 #include "options.h"
 #include "blkdev.h"
@@ -406,13 +408,19 @@
 #ifdef WIN32
 			struct _timeb tb1, tb2;
 #else
+#ifdef HAVE_SYS_TIMEB_H
 			struct timeb tb1, tb2;
+#else
+#warning Missing timing functions
+#endif
 #endif
 
 			idleframes = 0;
 			silentframes = 0;
 			foundsub = false;
+#ifdef HAVE_SYS_TIMEB_H
 			_ftime (&tb1);
+#endif
 			cdda_pos = cdu->cdda_start;
 			oldplay = cdu->cdda_play;
 			sector = cdu->cd_last_pos = cdda_pos;
@@ -467,9 +475,13 @@
 			cdda_pos -= idleframes;
 
 			if (*outpos < 0) {
+#ifdef HAVE_SYS_TIMEB_H
 			  _ftime (&tb2);
 			  diff = (tb2.time * (uae_s64)1000 + tb2.millitm) - (tb1.time * (uae_s64)1000 + tb1.millitm);
 			  diff -= cdu->cdda_delay;
+#else
+			  diff = 0;
+#endif
 			  if (idleframes >= 0 && diff < 0 && cdu->cdda_play > 0)
 				  sleep_millis(-diff);
 			  setstate (cdu, AUDIO_STATUS_IN_PROGRESS, cdda_pos);
diff -Nru src_93/cfgfile.cpp src/cfgfile.cpp
--- src_93/cfgfile.cpp	2019-08-10 17:34:48.000000000 +0300
+++ src/cfgfile.cpp	2019-08-10 17:37:32.252039526 +0300
@@ -147,7 +147,6 @@
 
 #define UNEXPANDED _T("$(FILE_PATH)")
 
-
 static TCHAR *cfgfile_unescape(const TCHAR *s, const TCHAR **endpos, TCHAR separator, bool min)
 {
 	bool quoted = false;
@@ -4308,22 +4307,20 @@
   p->sound_filter_type = 0;
 	p->sound_volume_cd = 20;
 
-#ifdef USE_JIT_FPU
+#if defined(USE_JIT_FPU)
 	p->compfpu = 1;
-#else
-	p->compfpu = 0;
 #endif
   p->cachesize = 0;
 
   p->gfx_framerate = 0;
 
-#ifdef RASPBERRY
+#if defined(RASPBERRY) || defined(ANDROID)
 	p->gfx_monitor.gfx_size.width = 640;
 	p->gfx_monitor.gfx_size.height = 262;
   p->gfx_resolution = RES_HIRES;
 #else
   p->gfx_monitor.gfx_size.width = 320;
-  p->gfx_monitor.gfx_size.height = 240;
+   p->gfx_monitor.gfx_size.height = 240;
   p->gfx_resolution = RES_LORES;
 #endif
 	p->gfx_vresolution = VRES_NONDOUBLE;
diff -Nru src_93/fpp_native.cpp src/fpp_native.cpp
--- src_93/fpp_native.cpp	2019-08-10 13:54:46.000000000 +0300
+++ src/fpp_native.cpp	2019-08-10 17:37:32.252039526 +0300
@@ -18,6 +18,9 @@
 #include <float.h>
 #include <fenv.h>
 
+#include "sysconfig.h"
+#include "sysdeps.h"
+
 #define USE_HOST_ROUNDING 1
 
 static uae_u32 dhex_nan[]   ={0xffffffff, 0x7fffffff};
diff -Nru src_93/fsusage.cpp src/fsusage.cpp
--- src_93/fsusage.cpp	2019-08-10 14:01:43.000000000 +0300
+++ src/fsusage.cpp	2019-08-10 17:37:32.252039526 +0300
@@ -24,7 +24,7 @@
 #if HAVE_SYS_STATFS_H
 # include <sys/statfs.h>
 #endif
-#ifdef STAT_STATVFS
+#if defined(STAT_STATVFS) && !defined(__ANDROID__)
 #include <sys/statvfs.h>
 #endif
 
@@ -287,9 +287,15 @@
 # define CONVERT_BLOCKS(B) \
     adjust_blocks ((B), fsd.f_frsize ? fsd.f_frsize : fsd.f_bsize, 512)
 
+#ifdef ANDROID
+  struct statfs fsd;
+
+  if (statfs (path, &fsd) < 0)
+#else
   struct statvfs fsd;
 
   if (statvfs (path, &fsd) < 0)
+#endif
     return -1;
   /* f_frsize isn't guaranteed to be supported.  */
 
diff -Nru src_93/include/options.h src/include/options.h
--- src_93/include/options.h	2019-08-10 14:01:43.000000000 +0300
+++ src/include/options.h	2019-08-10 17:37:32.252039526 +0300
@@ -421,6 +421,41 @@
 	int input_mouse_speed;
   int input_tablet;
 	int input_keyboard_type;
+
+    /* ANDROID */
+#ifdef ANDROIDSDL
+int onScreen;
+int onScreen_textinput;
+int onScreen_dpad;
+int onScreen_button1;
+int onScreen_button2;
+int onScreen_button3;
+int onScreen_button4;
+int onScreen_button5;
+int onScreen_button6;
+int custom_position;
+int pos_x_textinput;
+int pos_y_textinput;
+int pos_x_dpad;
+int pos_y_dpad;
+int pos_x_button1;
+int pos_y_button1;
+int pos_x_button2;
+int pos_y_button2;
+int pos_x_button3;
+int pos_y_button3;
+int pos_x_button4;
+int pos_y_button4;
+int pos_x_button5;
+int pos_y_button5;
+int pos_x_button6;
+int pos_y_button6;
+int extfilter;
+int quickSwitch;
+int floatingJoystick;
+int disableMenuVKeyb;
+#endif
+
 	struct uae_input_device joystick_settings[MAX_INPUT_SETTINGS][MAX_INPUT_DEVICES];
 	struct uae_input_device mouse_settings[MAX_INPUT_SETTINGS][MAX_INPUT_DEVICES];
 	struct uae_input_device keyboard_settings[MAX_INPUT_SETTINGS][MAX_INPUT_DEVICES];
diff -Nru src_93/jit/compemu_fpp.cpp src/jit/compemu_fpp.cpp
--- src_93/jit/compemu_fpp.cpp	2019-08-10 17:34:49.000000000 +0300
+++ src/jit/compemu_fpp.cpp	2019-08-10 17:37:32.252039526 +0300
@@ -25,6 +25,14 @@
 static const int sz1[8] = { 4, 4, 12, 12, 2, 8, 1, 0 };
 static const int sz2[8] = { 4, 4, 12, 12, 2, 8, 2, 0 };
 
+#ifdef ANDROID
+STATIC_INLINE double log2( double n )  
+{  
+    // log(n)/log(2) is log2.  
+    return log( n ) / log( 2 );  
+}
+#endif
+
 /* return the required floating point precision or -1 for failure, 0=E, 1=S, 2=D */
 STATIC_INLINE int comp_fp_get (uae_u32 opcode, uae_u16 extra, int treg)
 {
@@ -543,6 +551,7 @@
 		  }
 		  FAIL (1);
 		  return;
+#ifndef ANDROID
 		case 6:
 		case 7:
 		{
@@ -661,6 +670,7 @@
 			}
 		}
     return;
+#endif
 		case 2: /* from <EA> to FPx */
 		  dont_care_fflags ();
 		  if ((extra & 0xfc00) == 0x5c00) { /* FMOVECR */
diff -Nru src_93/osdep/caps/generic_caps.cpp src/osdep/caps/generic_caps.cpp
--- src_93/osdep/caps/generic_caps.cpp	2019-01-03 19:49:41.000000000 +0200
+++ src/osdep/caps/generic_caps.cpp	2019-08-10 17:37:32.256039396 +0300
@@ -66,7 +66,7 @@
 	if (init)
 		return 1;
 	TCHAR tmp[MAX_DPATH];
-	_tcscpy (tmp, _T("./capsimg.so"));
+	_tcscpy (tmp, _T("libcapsimage.so"));
 	UAE_DLHANDLE h = uae_dlopen(tmp);
 	if (!h) {
 		if (noticed)
Binary files src_93/osdep/caps/generic_caps.o and src/osdep/caps/generic_caps.o differ
diff -Nru src_93/osdep/config.h src/osdep/config.h
--- src_93/osdep/config.h	2019-01-03 19:49:41.000000000 +0200
+++ src/osdep/config.h	2019-08-10 17:37:32.256039396 +0300
@@ -66,14 +66,20 @@
  */
 #define VK_ESCAPE SDLK_ESCAPE
 
+#ifdef ANDROIDSDL
+#define VK_L SDLK_F13
+#else
+
 /*
  * Virtual Key for (Left shoulder) button
  * default: RSHIFT (303)
  */
 #define VK_L SDLK_RSHIFT
+#endif
 
 /*
  * Virtual Key for (Right shoulder) button
  * default: RCTRL (305)
  */
 #define VK_R SDLK_RCTRL
+
diff -Nru src_93/osdep/generic_filesys.cpp src/osdep/generic_filesys.cpp
--- src_93/osdep/generic_filesys.cpp	2019-08-10 14:01:43.000000000 +0300
+++ src/osdep/generic_filesys.cpp	2019-08-10 17:37:32.256039396 +0300
@@ -1,4 +1,6 @@
+#ifdef HAVE_SYS_TIMEB_H
 #include <sys/timeb.h>
+#endif
 #include <fcntl.h>
 #include <unistd.h>
 #include "sysconfig.h"
diff -Nru src_93/osdep/generic_mem.cpp src/osdep/generic_mem.cpp
--- src_93/osdep/generic_mem.cpp	2019-08-10 17:34:49.000000000 +0300
+++ src/osdep/generic_mem.cpp	2019-08-10 17:37:32.256039396 +0300
@@ -12,6 +12,9 @@
 #include "ar.h"
 #include <sys/mman.h>
 #include <SDL.h>
+#include <unistd.h>
+
+#define valloc(x) memalign(getpagesize(), x)
 
 struct uae_mman_data
 {
@@ -45,7 +48,7 @@
 {
   if(regs.natmem_offset != 0)
   {
-#ifdef RASPBERRY
+#ifdef ANDROID
     munmap(regs.natmem_offset, natmem_size + BARRIER);
 #else
     free(regs.natmem_offset);
@@ -78,7 +81,7 @@
   // First attempt: allocate 16 MB for all memory in 24-bit area 
   // and additional mem for Z3 and RTG at correct offset
   natmem_size = 16 * 1024 * 1024;
-#ifdef RASPBERRY
+#ifdef ANDROID
   // address returned by valloc() too high for later mmap() calls. Use mmap() also for first area.
   regs.natmem_offset = (uae_u8*) mmap((void *)0x20000000, natmem_size + BARRIER,
     PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS | MAP_FIXED, -1, 0);
@@ -125,7 +128,7 @@
     set_expamem_z3_hack_mode(Z3MAPPING_UAE);
     return;
   }
-#ifdef RASPBERRY
+#ifdef ANDROID
   munmap(regs.natmem_offset, natmem_size + BARRIER);
 #else
   free(regs.natmem_offset);
diff -Nru src_93/osdep/generic_target.cpp src/osdep/generic_target.cpp
--- src_93/osdep/generic_target.cpp	2019-08-10 14:01:43.000000000 +0300
+++ src/osdep/generic_target.cpp	2019-08-10 17:37:32.256039396 +0300
@@ -13,7 +13,9 @@
 #include <asm/sigcontext.h>
 #include <signal.h>
 #include <dlfcn.h>
+#ifndef ANDROID
 #include <execinfo.h>
+#endif
 #include "sysconfig.h"
 #include "sysdeps.h"
 #include "config.h"
@@ -441,10 +443,25 @@
 {
 	char path[MAX_DPATH];
   int i;
-
+#ifdef ANDROID
+	strncpy(currentDir, getenv("SDCARD"), MAX_DPATH - 1);
+#else
 	strncpy(currentDir, start_path_data, MAX_DPATH - 1);
+#endif
 	snprintf(config_path, MAX_DPATH - 1, "%s/conf/", start_path_data);
+#ifdef ANDROID
+    char afepath[MAX_DPATH];
+    snprintf(afepath, MAX_DPATH - 1, "%s/Android/data/com.cloanto.amigaforever.essentials/files/rom/", getenv("SDCARD"));
+    DIR *afedir = opendir(afepath);
+    if (afedir) {
+        snprintf(rom_path, MAX_DPATH - 1, "%s", afepath);
+        closedir(afedir);
+    }
+	else
+        snprintf(rom_path, MAX_DPATH - 1, "%s/kickstarts/", start_path_data);
+#else
 	snprintf(rom_path, MAX_DPATH - 1, "%s/kickstarts/", start_path_data);
+#endif
 	snprintf(rp9_path, MAX_DPATH - 1, "%s/rp9/", start_path_data);
 
 	snprintf(path, MAX_DPATH - 1, "%s/conf/adfdir.conf", start_path_data);
diff -Nru src_93/osdep/gui/androidsdl_event.cpp src/osdep/gui/androidsdl_event.cpp
--- src_93/osdep/gui/androidsdl_event.cpp	1970-01-01 03:00:00.000000000 +0300
+++ src/osdep/gui/androidsdl_event.cpp	2019-08-10 17:37:32.256039396 +0300
@@ -0,0 +1,64 @@
+#include <guichan/sdl.hpp>
+
+void androidsdl_event(SDL_Event event, gcn::SDLInput* gui_input) {
+            /*
+             * Now that we are done polling and using SDL events we pass
+             * the leftovers to the SDLInput object to later be handled by
+             * the Gui. (This example doesn't require us to do this 'cause a
+             * label doesn't use input. But will do it anyway to show how to
+             * set up an SDL application with Guichan.)
+             */
+            if (event.type == SDL_MOUSEMOTION ||
+                event.type == SDL_MOUSEBUTTONDOWN ||
+                event.type == SDL_MOUSEBUTTONUP) {
+                // Filter emulated mouse events for Guichan, we wand absolute input
+            } else {
+                // Convert multitouch event to SDL mouse event
+                static int x = 0, y = 0, buttons = 0, wx=0, wy=0, pr=0;
+                SDL_Event event2;
+                memcpy(&event2, &event, sizeof(event));
+                if (event.type == SDL_JOYBALLMOTION &&
+                    event.jball.which == 0 &&
+                    event.jball.ball == 0) {
+                    event2.type = SDL_MOUSEMOTION;
+                    event2.motion.which = 0;
+                    event2.motion.state = buttons;
+                    event2.motion.xrel = event.jball.xrel - x;
+                    event2.motion.yrel = event.jball.yrel - y;
+                    if (event.jball.xrel!=0) {
+                        x = event.jball.xrel;
+                        y = event.jball.yrel;
+                    }
+                    event2.motion.x = x;
+                    event2.motion.y = y;
+                    //__android_log_print(ANDROID_LOG_INFO, "GUICHAN","Mouse motion %d %d btns %d", x, y, buttons);
+                    if (buttons == 0) {
+                        // Push mouse motion event first, then button down event
+                        gui_input->pushInput(event2);
+                        buttons = SDL_BUTTON_LMASK;
+                        event2.type = SDL_MOUSEBUTTONDOWN;
+                        event2.button.which = 0;
+                        event2.button.button = SDL_BUTTON_LEFT;
+                        event2.button.state =  SDL_PRESSED;
+                        event2.button.x = x;
+                        event2.button.y = y;
+                        //__android_log_print(ANDROID_LOG_INFO, "GUICHAN","Mouse button %d coords %d %d", buttons, x, y);
+                    }
+                }
+                if (event.type == SDL_JOYBUTTONUP &&
+                    event.jbutton.which == 0 &&
+                    event.jbutton.button == 0) {
+                    // Do not push button down event here, because we need mouse motion event first
+                    buttons = 0;
+                    event2.type = SDL_MOUSEBUTTONUP;
+                    event2.button.which = 0;
+                    event2.button.button = SDL_BUTTON_LEFT;
+                    event2.button.state = SDL_RELEASED;
+                    event2.button.x = x;
+                    event2.button.y = y;
+                    //__android_log_print(ANDROID_LOG_INFO, "GUICHAN","Mouse button %d coords %d %d", buttons, x, y);
+                }
+                gui_input->pushInput(event2);
+            }
+}
+
diff -Nru src_93/osdep/gui/androidsdl_event.h src/osdep/gui/androidsdl_event.h
--- src_93/osdep/gui/androidsdl_event.h	1970-01-01 03:00:00.000000000 +0300
+++ src/osdep/gui/androidsdl_event.h	2019-08-10 17:37:32.256039396 +0300
@@ -0,0 +1,2 @@
+void androidsdl_event(SDL_Event event, gcn::SDLInput* gui_input);
+
diff -Nru src_93/osdep/gui/CreateFilesysHardfile.cpp src/osdep/gui/CreateFilesysHardfile.cpp
--- src_93/osdep/gui/CreateFilesysHardfile.cpp	2019-08-10 17:34:49.000000000 +0300
+++ src/osdep/gui/CreateFilesysHardfile.cpp	2019-08-10 17:37:32.256039396 +0300
@@ -23,6 +23,9 @@
 #include "gui.h"
 #include "gui_handling.h"
 
+#ifdef ANDROIDSDL
+#include "androidsdl_event.h"
+#endif
 
 #define DIALOG_WIDTH 620
 #define DIALOG_HEIGHT 202
@@ -254,7 +257,11 @@
       //-------------------------------------------------
       // Send event to guichan/guisan-controls
       //-------------------------------------------------
-      gui_input->pushInput(event);
+#ifdef ANDROIDSDL
+        androidsdl_event(event, gui_input);
+#else
+        gui_input->pushInput(event);
+#endif
     }
 
     // Now we let the Gui object perform its logic.
diff -Nru src_93/osdep/gui/EditFilesysHardfile.cpp src/osdep/gui/EditFilesysHardfile.cpp
--- src_93/osdep/gui/EditFilesysHardfile.cpp	2019-08-10 17:34:49.000000000 +0300
+++ src/osdep/gui/EditFilesysHardfile.cpp	2019-08-10 17:37:32.256039396 +0300
@@ -25,6 +25,9 @@
 #include "gui_handling.h"
 #include "GenericListModel.h"
 
+#ifdef ANDROIDSDL
+#include "androidsdl_event.h"
+#endif
 
 #define DIALOG_WIDTH 620
 #define DIALOG_HEIGHT 272
@@ -396,7 +399,11 @@
       //-------------------------------------------------
       // Send event to guichan/guisan-controls
       //-------------------------------------------------
-      gui_input->pushInput(event);
+#ifdef ANDROIDSDL
+        androidsdl_event(event, gui_input);
+#else
+        gui_input->pushInput(event);
+#endif
     }
 
     // Now we let the Gui object perform its logic.
diff -Nru src_93/osdep/gui/EditFilesysVirtual.cpp src/osdep/gui/EditFilesysVirtual.cpp
--- src_93/osdep/gui/EditFilesysVirtual.cpp	2019-08-10 17:34:49.000000000 +0300
+++ src/osdep/gui/EditFilesysVirtual.cpp	2019-08-10 17:37:32.256039396 +0300
@@ -23,10 +23,15 @@
 #include "gui.h"
 #include "gui_handling.h"
 
+#ifdef ANDROIDSDL
+#include "androidsdl_event.h"
+#endif
 
 #define DIALOG_WIDTH 520
 #define DIALOG_HEIGHT 202
 
+extern std::string volName;
+
 static bool dialogResult = false;
 static bool dialogFinished = false;
 
@@ -55,8 +60,10 @@
         char tmp[MAX_PATH];
         strncpy(tmp, txtPath->getText().c_str(), MAX_PATH - 1);
         wndEditFilesysVirtual->releaseModalFocus();
-        if(SelectFolder("Select folder", tmp))
+        if(SelectFolder("Select folder", tmp)) {
           txtPath->setText(tmp);
+          txtVolume->setText(volName);
+	    }
         wndEditFilesysVirtual->requestModalFocus();
         cmdPath->requestFocus();
 
@@ -258,7 +265,11 @@
       //-------------------------------------------------
       // Send event to guichan/guisan-controls
       //-------------------------------------------------
-      gui_input->pushInput(event);
+#ifdef ANDROIDSDL
+        androidsdl_event(event, gui_input);
+#else
+        gui_input->pushInput(event);
+#endif
     }
 
     // Now we let the Gui object perform its logic.
diff -Nru src_93/osdep/gui/gui_handling.h src/osdep/gui/gui_handling.h
--- src_93/osdep/gui/gui_handling.h	2019-08-10 13:54:46.000000000 +0300
+++ src/osdep/gui/gui_handling.h	2019-08-10 17:37:32.256039396 +0300
@@ -114,6 +114,12 @@
 void ExitPanelSavestate(const struct _ConfigCategory& category);
 bool HelpPanelSavestate(std::vector<std::string> &helptext);
   
+#ifdef ANDROIDSDL
+void InitPanelOnScreen(const struct _ConfigCategory& category);
+void ExitPanelOnScreen(const struct _ConfigCategory& category);
+bool HelpPanelOnScreen(std::vector<std::string> &helptext);
+#endif
+
 void RegisterRefreshFunc(void (*func)(void));
 
 void FocusBugWorkaround(gcn::Window *wnd);
diff -Nru src_93/osdep/gui/main_window.cpp src/osdep/gui/main_window.cpp
--- src_93/osdep/gui/main_window.cpp	2019-08-10 17:34:49.000000000 +0300
+++ src/osdep/gui/main_window.cpp	2019-08-10 17:37:32.256039396 +0300
@@ -20,6 +20,13 @@
 #include "include/memory-uae.h"
 #include "autoconf.h"
 
+#if defined(ANDROIDSDL)
+#include "androidsdl_event.h"
+#include <SDL_screenkeyboard.h>
+#include <SDL_android.h>
+#include <android/log.h>
+#endif
+
 #ifdef USE_SDL2
 extern SDL_Renderer* renderer;
 extern SDL_DisplayMode sdlMode;
@@ -66,12 +73,20 @@
   { "Input",            "data/joystick.ico",  NULL, NULL, InitPanelInput,     ExitPanelInput,     HelpPanelInput },
   { "Miscellaneous",    "data/misc.ico",      NULL, NULL, InitPanelMisc,      ExitPanelMisc,      HelpPanelMisc },
   { "Savestates",       "data/savestate.png", NULL, NULL, InitPanelSavestate, ExitPanelSavestate, HelpPanelSavestate },
+#ifdef ANDROIDSDL  
+  { "OnScreen",         "data/screen.ico",    NULL, NULL, InitPanelOnScreen,  ExitPanelOnScreen,  HelpPanelOnScreen },
+#endif
   { NULL, NULL, NULL, NULL, NULL, NULL, NULL }
 };
+#ifdef ANDROIDSDL
+enum { PANEL_PATHS, PANEL_QUICKSTART, PANEL_CONFIGURATIONS, PANEL_CPU, PANEL_CHIPSET, PANEL_ROM, PANEL_RAM,
+       PANEL_FLOPPY, PANEL_HD, PANEL_DISPLAY, PANEL_SOUND, PANEL_GAMEPORT, PANEL_INPUT, PANEL_MISC, PANEL_SAVESTATES, 
+       PANEL_ONSCREEN, NUM_PANELS };
+#else
 enum { PANEL_PATHS, PANEL_QUICKSTART, PANEL_CONFIGURATIONS, PANEL_CPU, PANEL_CHIPSET, PANEL_ROM, PANEL_RAM,
        PANEL_FLOPPY, PANEL_HD, PANEL_DISPLAY, PANEL_SOUND, PANEL_GAMEPORT, PANEL_INPUT, PANEL_MISC, PANEL_SAVESTATES, 
        NUM_PANELS };
-
+#endif
 
 #ifdef USE_SDL2
 SDL_Texture* gui_texture;
@@ -284,6 +299,11 @@
 		gui_screen = SDL_SetVideoMode(GUI_WIDTH, GUI_HEIGHT, 16, SDL_SWSURFACE | SDL_FULLSCREEN);
     SDL_EnableUNICODE(1);
     SDL_EnableKeyRepeat(SDL_DEFAULT_REPEAT_DELAY, SDL_DEFAULT_REPEAT_INTERVAL);
+#ifdef ANDROIDSDL
+    // Enable Android multitouch
+    SDL_InitSubSystem(SDL_INIT_JOYSTICK);
+    SDL_JoystickOpen(0);
+#endif
     SDL_ShowCursor(SDL_ENABLE);
 #endif
 
@@ -339,7 +359,7 @@
   			uae_quit();
   			gui_running = false;
   			break;
-
+#ifndef ANDROIDSDL
   		} else if (gui_event.type == SDL_JOYAXISMOTION) {
         //-------------------------------------------------
         // Navigate with joystick
@@ -381,7 +401,7 @@
         gui_event.key.keysym.sym = SDLK_RETURN;
         gui_input->pushInput(gui_event); // Fire key down
         gui_event.type = SDL_KEYUP;  // and the key up
-          
+#endif          
   		} else if (gui_event.type == SDL_KEYDOWN) {
         gcn::FocusHandler* focusHdl;
         gcn::Widget* activeWidget;
@@ -407,6 +427,7 @@
         } else {
           switch(gui_event.key.keysym.sym)
           {
+#ifndef ANDROID
             case SDLK_q:
               //-------------------------------------------------
               // Quit entire program via Q on keyboard
@@ -428,7 +449,7 @@
         			uae_reset(1, 1);
         			gui_running = false;
         			break;
-
+#endif
 					  case VK_X:
 					  case VK_A:
               //------------------------------------------------
@@ -470,7 +491,11 @@
       //-------------------------------------------------
       // Send event to guichan/guisan-controls
       //-------------------------------------------------
-      gui_input->pushInput(gui_event);
+#ifdef ANDROIDSDL
+        androidsdl_event(gui_event, gui_input);
+#else
+        gui_input->pushInput(gui_event);
+#endif
     }
   }
 
@@ -651,8 +676,12 @@
 #ifdef USE_SDL2
 		gui_font = new gcn::SDLTrueTypeFont("data/FreeSans.ttf", 14);
 #else
+#ifdef ANDROID
+	  gui_font = new gcn::contrib::SDLTrueTypeFont("data/FreeSans.ttf", 16);	  
+#else
 	  gui_font = new gcn::contrib::SDLTrueTypeFont("data/FreeSans.ttf", 14);
 #endif
+#endif
     gcn::Widget::setGlobalFont(gui_font);
     
   	//--------------------------------------------------
@@ -738,7 +767,9 @@
   	//--------------------------------------------------
     gui_top->add(cmdReset, DISTANCE_BORDER, GUI_HEIGHT - DISTANCE_BORDER - BUTTON_HEIGHT);
     gui_top->add(cmdQuit, DISTANCE_BORDER + BUTTON_WIDTH + DISTANCE_NEXT_X, GUI_HEIGHT - DISTANCE_BORDER - BUTTON_HEIGHT);
+#ifndef ANDROID
     gui_top->add(cmdShutdown, DISTANCE_BORDER + 2 * BUTTON_WIDTH + 2 * DISTANCE_NEXT_X, GUI_HEIGHT - DISTANCE_BORDER - BUTTON_HEIGHT);
+#endif
     gui_top->add(cmdHelp, DISTANCE_BORDER + 3 * BUTTON_WIDTH + 3 * DISTANCE_NEXT_X, GUI_HEIGHT - DISTANCE_BORDER - BUTTON_HEIGHT);
     if(emulating)
       gui_top->add(cmdRestart, GUI_WIDTH - DISTANCE_BORDER - 2 * BUTTON_WIDTH - DISTANCE_NEXT_X, GUI_HEIGHT - DISTANCE_BORDER - BUTTON_HEIGHT);
@@ -794,6 +825,8 @@
 
 void DisableResume(void)
 {
+// Disable resume button after loading config is very bad idea
+#ifndef ANDROID
 	if(emulating)
   {
     widgets::cmdStart->setEnabled(false);
@@ -803,11 +836,16 @@
     backCol.b = 128;
     widgets::cmdStart->setForegroundColor(backCol);
   }
+#endif
 }
 
 
 void run_gui(void)
 {
+#ifdef ANDROIDSDL
+  SDL_ANDROID_SetScreenKeyboardShown(0);
+  SDL_ANDROID_SetSystemMousePointerVisible(1);
+#endif
   gui_running = true;
   gui_rtarea_flags_onenter = gui_create_rtarea_flag(&currprefs);
   
@@ -824,25 +862,32 @@
     sdl::gui_run();
     widgets::gui_halt();
     sdl::gui_halt();
+#ifdef ANDROIDSDL
+    if (currprefs.onScreen!=0)
+    {
+       SDL_ANDROID_SetScreenKeyboardShown(1);
+       SDL_ANDROID_SetSystemMousePointerVisible(0);
+    }
+#endif
   }
   // Catch all Guichan/Guisan exceptions.
   catch (gcn::Exception e)
   {
-    printf("%s\n", e.getMessage().c_str());
+    std::cout << e.getMessage() << std::endl;
     uae_quit();
   }
 
   // Catch all Std exceptions.
   catch (std::exception e)
   {
-    printf("Std exception: %s\n", e.what());
+    std::cout << "Std exception: " << e.what() << std::endl;
     uae_quit();
   }
 	
   // Catch all unknown exceptions.
   catch (...)
   {
-    printf("Unknown exception\n");
+    std::cout << "Unknown exception" << std::endl;
     uae_quit();
   }
 
diff -Nru src_93/osdep/gui/Navigation.cpp src/osdep/gui/Navigation.cpp
--- src_93/osdep/gui/Navigation.cpp	2019-01-03 19:49:41.000000000 +0200
+++ src/osdep/gui/Navigation.cpp	2019-08-10 17:37:32.256039396 +0300
@@ -44,13 +44,22 @@
   { "Game ports",       "cboAutofire0",   "cboPort0",       "Sound",            "Input" },
   { "Input",            "cboDevice",      "cboDevice",      "Game ports",       "Miscellaneous" },
   { "Miscellaneous",    "ShowGUI",        "ShowGUI",        "Input",            "Savestates" },
+#ifdef ANDROIDSDL
+  { "Savestates",       "State0",         "State0",         "Miscellaneous",    "OnScreen" },
+  { "OnScreen",         "OnScrButton3",   "OnScrCtrl",      "Savestates",     "Reset" },
+  { "Reset",            "Start",          "Quit",           "OnScreen",       "Paths" },
+  { "Quit",             "Reset",          "Help",           "OnScreen",       "Paths" },
+  { "Help",             "Quit",           "Start",          "OnScreen",       "Paths" },
+  { "Start",            "Help",           "Reset",          "OnScreen",       "Paths" },
+#else
   { "Savestates",       "State0",         "State0",         "Miscellaneous",    "Reset" },
   { "Reset",            "Start",          "Quit",           "Savestates",       "Paths" },
   { "Quit",             "Reset",          "Shutdown",       "Savestates",       "Paths" },
   { "Shutdown",         "Quit",           "Help",           "Savestates",       "Paths" },
   { "Help",             "Shutdown",       "Start",          "Savestates",       "Paths" },
   { "Start",            "Help",           "Reset",          "Savestates",       "Paths" },
-
+#endif
+	
 // PanelPaths
   { "SystemROMs",     "Paths",          "Paths",          "RescanROMs",     "ConfigPath" },
   { "ConfigPath",     "Paths",          "Paths",          "SystemROMs",     "RescanROMs" },
@@ -299,6 +308,21 @@
   { "LoadState",      "Savestates",     "SaveState",      "State3",         "State0" },
   { "SaveState",      "LoadState",      "Savestates",     "State3",         "State0" },
 
+#ifdef ANDROIDSDL
+// PanelOnScreen
+  { "OnScrCtrl",      "OnScreen",       "OnScrButton3", "DisableMenuVKeyb", "OnScrTextInput" },
+  { "OnScrButton3",   "OnScrCtrl",      "OnScreen",     "CustomPos",     "OnScrButton4" },
+  { "OnScrTextInput", "OnScreen",       "OnScrButton4", "OnScrCtrl",      "OnScrDpad" },
+  { "OnScrButton4",   "OnScrTextInput", "OnScreen",     "OnScrButton3",   "OnScrButton5" },
+  { "OnScrDpad",      "OnScreen",       "OnScrButton5", "OnScrTextInput", "OnScrButton1" },
+  { "OnScrButton5",   "OnScrDpad",      "OnScreen",     "OnScrButton4",   "OnScrButton6" },
+  { "OnScrButton1",   "OnScreen",       "OnScrButton6", "OnScrDpad",      "OnScrButton2" },
+  { "OnScrButton6",   "OnScrButton1",   "OnScreen",     "OnScrButton5",   "CustomPos" },
+  { "OnScrButton2",   "OnScreen",       "CustomPos",    "OnScrButton1",   "FloatJoy" },
+  { "CustomPos",      "OnScrButton2",   "OnScreen",     "OnScrButton6",   "Reset" },
+  { "FloatJoy",       "OnScreen",       "CustomPos",    "OnScrButton2",   "DisableMenuVKeyb" },
+  { "DisableMenuVKeyb","OnScreen",       "CustomPos",    "FloatJoy",       "Reset" },
+#endif
 
 //  active            move left         move right        move up           move down
 // EditFilesysVirtual
diff -Nru src_93/osdep/gui/PanelChipset.cpp src/osdep/gui/PanelChipset.cpp
--- src_93/osdep/gui/PanelChipset.cpp	2019-08-10 17:34:49.000000000 +0300
+++ src/osdep/gui/PanelChipset.cpp	2019-08-10 17:37:32.256039396 +0300
@@ -214,10 +214,18 @@
   chkNTSC->addActionListener(chipsetActionListener);
 
   lblChipset = new gcn::Label("Extra:");
+#ifdef ANDROID
+  lblChipset->setSize(42, LABEL_HEIGHT);
+#else
   lblChipset->setSize(40, LABEL_HEIGHT);
+#endif
   lblChipset->setAlignment(gcn::Graphics::RIGHT);
 	cboChipset = new gcn::UaeDropDown(&chipsetList);
+#ifdef ANDROID
+  cboChipset->setSize(78, DROPDOWN_HEIGHT);
+#else
   cboChipset->setSize(75, DROPDOWN_HEIGHT);
+#endif
   cboChipset->setBaseColor(gui_baseCol);
   cboChipset->setId("ChipsetExtra");
   cboChipset->addActionListener(chipsetActionListener);
@@ -233,7 +241,11 @@
 	grpChipset->add(cboChipset, 115 + lblChipset->getWidth() + 8, 10);
 
 	grpChipset->setMovable(false);
+#ifdef ANDROID
+	grpChipset->setSize(260, 185);
+#else
 	grpChipset->setSize(255, 185);
+#endif
   grpChipset->setBaseColor(gui_baseCol);
   
   category.panel->add(grpChipset);
@@ -255,7 +267,11 @@
 	grpBlitter->add(optBlitImmed, 5, 40);
 	grpBlitter->add(optBlitWait, 5, 70);
 	grpBlitter->setMovable(false);
+#ifdef ANDROID
+	grpBlitter->setSize(125, 115);
+#else
 	grpBlitter->setSize(120, 115);
+#endif
   grpBlitter->setBaseColor(gui_baseCol);
   
   category.panel->add(grpBlitter);
@@ -267,7 +283,11 @@
 	grpCopper->setPosition(DISTANCE_BORDER + grpChipset->getWidth() + DISTANCE_NEXT_X, grpBlitter->getY() + grpBlitter->getHeight() + DISTANCE_NEXT_Y);
 	grpCopper->add(chkFastCopper, 5, 10);
 	grpCopper->setMovable(false);
+#ifdef ANDROID
+	grpCopper->setSize(130, 55);
+#else
 	grpCopper->setSize(120, 55);
+#endif
   grpCopper->setBaseColor(gui_baseCol);
 
   category.panel->add(grpCopper);
@@ -294,7 +314,11 @@
 	grpCollisionLevel->add(optCollPlayfield, 5, 70);
 	grpCollisionLevel->add(optCollFull, 5, 100);
 	grpCollisionLevel->setMovable(false);
+#ifdef ANDROID
+	grpCollisionLevel->setSize(270, 145);
+#else
 	grpCollisionLevel->setSize(250, 145);
+#endif
   grpCollisionLevel->setBaseColor(gui_baseCol);
   
   category.panel->add(grpCollisionLevel);
@@ -342,14 +366,14 @@
   helptext.push_back("expected. By selecting an entry in \"Extra\", all internal chipset settings will become the required values for the");
   helptext.push_back("specified Amiga model.");
   helptext.push_back("For some games, you have to activate \"NTSC\" (60 Hz instead of 50 Hz) for correct timing.");
-  helptext.push_back("");
+  helptext.push_back(" ");
   helptext.push_back("When you see some graphic issues in a game, try \"Immediate\" or \"Wait for blit.\" for blitter and/or disable");
   helptext.push_back("\"Fast copper\".");
-  helptext.push_back("");
+  helptext.push_back(" ");
   helptext.push_back("\"Fast copper\" uses a prediction algorithm instead of checking the copper state on a more regular basis. This may");
   helptext.push_back("cause issues but brings a big performance improvement. The option was removed in WinUAE in an early state,");
   helptext.push_back("but for most games, it works fine and the better performance is helpful for low powered devices.");
-  helptext.push_back("");
+  helptext.push_back(" ");
   helptext.push_back("For \"Collision Level\", select \"Sprites and Sprites vs. Playfield\" which is fine for nearly all games.");
   return true;
 }
diff -Nru src_93/osdep/gui/PanelConfig.cpp src/osdep/gui/PanelConfig.cpp
--- src_93/osdep/gui/PanelConfig.cpp	2019-08-10 13:54:46.000000000 +0300
+++ src/osdep/gui/PanelConfig.cpp	2019-08-10 17:37:32.256039396 +0300
@@ -283,10 +283,10 @@
   helptext.clear();
   helptext.push_back("To load a configuration, select the entry in the list and then click on \"Load\". If you doubleclick on an entry in the");
   helptext.push_back("list, the emulation starts with this configuration.");
-  helptext.push_back("");
+  helptext.push_back(" ");
   helptext.push_back("If you want to create a new configuration, setup all options, enter a new name in \"Name\", provide a short");
   helptext.push_back("description and then click on \"Save\".");
-  helptext.push_back("");
+  helptext.push_back(" ");
   helptext.push_back("\"Delete\" will delete the selected configuration.");
   return true;
 }
diff -Nru src_93/osdep/gui/PanelCPU.cpp src/osdep/gui/PanelCPU.cpp
--- src_93/osdep/gui/PanelCPU.cpp	2019-08-10 17:34:49.000000000 +0300
+++ src/osdep/gui/PanelCPU.cpp	2019-08-10 17:37:32.256039396 +0300
@@ -270,7 +270,11 @@
 	grpCPU->add(sldCachemem, 6, 290);
 	grpCPU->add(lblCachesize, 110, 290);
 	grpCPU->setMovable(false);
+#ifdef ANDROID
+	grpCPU->setSize(165, 335);
+#else
 	grpCPU->setSize(160, 335);
+#endif
   grpCPU->setBaseColor(gui_baseCol);
   
   category.panel->add(grpCPU);
@@ -329,7 +333,11 @@
 	grpCPUSpeed->add(opt28Mhz, 5, 70);
 	grpCPUSpeed->add(optFastest, 5, 100);
 	grpCPUSpeed->setMovable(false);
+#ifdef ANDROID
+	grpCPUSpeed->setSize(100, 145);
+#else
 	grpCPUSpeed->setSize(95, 145);
+#endif
   grpCPUSpeed->setBaseColor(gui_baseCol);
 
   category.panel->add(grpCPUSpeed);
@@ -380,18 +388,18 @@
   helptext.push_back("If you select 68020, you can choose between 24-bit addressing (68EC020) or 32-bit addressing (68020).");
   helptext.push_back("The option \"More compatible\" is only available if 68000 or 68010 is selected and emulates simple prefetch of");
   helptext.push_back("the 68000. This may improve compatibility in few situations but is not required for most games and demos.");
-  helptext.push_back("");
+  helptext.push_back(" ");
   helptext.push_back("JIT enables the Just-in-time compiler. This may break compatibility in some games. With \"Cache\", you can select");
   helptext.push_back("the size of the memory for compiled code.");
-  helptext.push_back("");
+  helptext.push_back(" ");
   helptext.push_back("The available FPU models depending on the selected CPU.");
   helptext.push_back("The option \"More compatible\" activates more accurate rounding and compare of two floats.");
-  helptext.push_back("");
+  helptext.push_back(" ");
   helptext.push_back("With \"CPU Speed\" you can choose the clock rate of the Amiga.");
-  helptext.push_back("");
+  helptext.push_back(" ");
   helptext.push_back("In current version, you will not see a difference in the performance for 68020, 68030 and 68040 CPUs. The cpu");
   helptext.push_back("cycles for the opcodes are based on 68020. The different cycles for 68030 and 68040 may come in a later");
   helptext.push_back("version.");
   return true;
 }
-  
\ No newline at end of file
+  
diff -Nru src_93/osdep/gui/PanelDisplay.cpp src/osdep/gui/PanelDisplay.cpp
--- src_93/osdep/gui/PanelDisplay.cpp	2019-08-10 17:34:49.000000000 +0300
+++ src/osdep/gui/PanelDisplay.cpp	2019-08-10 17:37:32.256039396 +0300
@@ -288,15 +288,15 @@
   helptext.push_back("Select the required width and height of the Amiga screen. If you select \"NTSC\" in chipset, a value greater than");
   helptext.push_back("240 for \"Height\" makes no sense. When the game, demo or workbench uses Hires mode and you selected a");
   helptext.push_back("value for \"Width\" lower than 640, you will only see half of the pixels.");
-  helptext.push_back("");
+  helptext.push_back(" ");
   helptext.push_back("With \"Vert. offset\" you can adjust the position of the first drawn line of the Amiga screen.");
-  helptext.push_back("");
+  helptext.push_back(" ");
 #if defined(RASPBERRY) && !defined(USE_SDL2)
   helptext.push_back("Activate \"4/3 ratio shrink\" to force display to this aspect ratio.");
-  helptext.push_back("");
+  helptext.push_back(" ");
 #endif
   helptext.push_back("Activate line doubling to remove flicker in interlace modes.");
-  helptext.push_back("");
+  helptext.push_back(" ");
   helptext.push_back("When you activate \"Frameskip\", only every second frame is drawn. This will improve performance and some");
   helptext.push_back("more games are playable.");
   return true;
diff -Nru src_93/osdep/gui/PanelFloppy.cpp src/osdep/gui/PanelFloppy.cpp
--- src_93/osdep/gui/PanelFloppy.cpp	2019-08-10 17:34:49.000000000 +0300
+++ src/osdep/gui/PanelFloppy.cpp	2019-08-10 17:37:32.260039266 +0300
@@ -418,7 +418,11 @@
 	for(i = 0; i < 4; ++i) {
 	  posX = DISTANCE_BORDER;
 	  category.panel->add(chkDFx[i], posX, posY);
+#ifdef ANDROID
+	  posX += 85;
+#else
 	  posX += 100;
+#endif
 	  category.panel->add(cboDFxType[i], posX, posY);
 	  posX += cboDFxType[i]->getWidth() + 2 * DISTANCE_NEXT_X;
 	  category.panel->add(chkDFxWriteProtect[i], posX, posY);
@@ -489,13 +493,13 @@
   helptext.push_back("disk file may fail because of missing rights on the host filesystem.");
   helptext.push_back("The button \"...\" opens a dialog to select the required disk file. With the dropdown control, you can select one of");
   helptext.push_back("the disks you recently used.");
-  helptext.push_back("");
+  helptext.push_back(" ");
   helptext.push_back("You can reduce the loading time for lot of games by increasing the floppy drive emulation speed. A few games");
   helptext.push_back("will not load with higher drive speed and you have to select 100%.");
-  helptext.push_back("");
+  helptext.push_back(" ");
   helptext.push_back("\"Save config for disk\" will create a new configuration file with the name of the disk in DF0. This configuration will");
   helptext.push_back("be loaded each time you select the disk and have the option \"Load config with same name as disk\" enabled.");
-  helptext.push_back("");
+  helptext.push_back(" ");
   helptext.push_back("With the buttons \"Create 3.5'' DD disk\" and \"Create 3.5'' HD disk\" you can create a new and empty disk.");
   return true;
 }
diff -Nru src_93/osdep/gui/PanelGamePortPandora.cpp src/osdep/gui/PanelGamePortPandora.cpp
--- src_93/osdep/gui/PanelGamePortPandora.cpp	2019-08-10 17:34:49.000000000 +0300
+++ src/osdep/gui/PanelGamePortPandora.cpp	2019-08-10 17:37:32.260039266 +0300
@@ -20,6 +20,9 @@
 #include "inputdevice.h"
 #include "GenericListModel.h"
 
+#ifdef ANDROIDSDL
+#include <SDL_android.h>
+#endif
 
 static int total_devices;
 
@@ -222,6 +225,12 @@
           workprefs.pandora_tapDelay = 2;
 
       } else if (actionEvent.getSource() == chkMouseHack) {
+#ifdef ANDROIDSDL
+        if (chkMouseHack->isSelected())
+             SDL_ANDROID_SetMouseEmulationMode(0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1);
+        else
+             SDL_ANDROID_SetMouseEmulationMode(1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1);
+#endif
   	    workprefs.input_tablet = chkMouseHack->isSelected() ? TABLET_MOUSEHACK : TABLET_OFF;
   	  }
     }
@@ -288,7 +297,11 @@
   cboAutofires[1]->addActionListener(gameportActionListener);
 
 	lblMouseSpeed = new gcn::Label("Mouse Speed:");
+#ifdef ANDROID
+  lblMouseSpeed->setSize(105, LABEL_HEIGHT);
+#else
   lblMouseSpeed->setSize(95, LABEL_HEIGHT);
+#endif
   lblMouseSpeed->setAlignment(gcn::Graphics::RIGHT);
   sldMouseSpeed = new gcn::Slider(0, 4);
   sldMouseSpeed->setSize(110, SLIDER_HEIGHT);
@@ -300,7 +313,11 @@
   lblMouseSpeedInfo = new gcn::Label(".25");
 
 	lblAutofireRate = new gcn::Label("Autofire rate:");
+#ifdef ANDROID
+  lblAutofireRate->setSize(94, LABEL_HEIGHT);
+#else
   lblAutofireRate->setSize(82, LABEL_HEIGHT);
+#endif
   lblAutofireRate->setAlignment(gcn::Graphics::RIGHT);
   sldAutofireRate = new gcn::Slider(1, 40);
   sldAutofireRate->setSize(117, SLIDER_HEIGHT);
@@ -341,8 +358,13 @@
   category.panel->add(lblMouseSpeed, DISTANCE_BORDER, posY);
   category.panel->add(sldMouseSpeed, DISTANCE_BORDER + lblMouseSpeed->getWidth() + 9, posY);
   category.panel->add(lblMouseSpeedInfo, sldMouseSpeed->getX() + sldMouseSpeed->getWidth() + 12, posY);
+#ifdef ANDROID
+  category.panel->add(lblAutofireRate, 290, posY);
+  category.panel->add(sldAutofireRate, 290 + lblAutofireRate->getWidth() + 9, posY);
+#else
   category.panel->add(lblAutofireRate, 300, posY);
   category.panel->add(sldAutofireRate, 300 + lblAutofireRate->getWidth() + 9, posY);
+#endif
   category.panel->add(lblAutofireRateInfo, sldAutofireRate->getX() + sldAutofireRate->getWidth() + 12, posY);
   posY += sldAutofireRate->getHeight() + DISTANCE_NEXT_Y;
 
@@ -386,13 +408,13 @@
 {
   helptext.clear();
   helptext.push_back("You can select the control type for both ports and the rate for autofire.");
-  helptext.push_back("");
+  helptext.push_back(" ");
   helptext.push_back("Set the emulated mouse speed to .25x, .5x, 1x, 2x and 4x to slow down or speed up the mouse.");
-  helptext.push_back("");
+  helptext.push_back(" ");
   helptext.push_back("When \"Enable mousehack\" is activated, you can use the stylus to set the mouse pointer to the exact position.");
   helptext.push_back("This works very well on Workbench, but many games using there own mouse handling and will not profit from");
   helptext.push_back("this code.");
-  helptext.push_back("");
+  helptext.push_back(" ");
   helptext.push_back("\"Tap Delay\" specifies the time between taping the screen and an emulated mouse button click.");
   return true;
 }
diff -Nru src_93/osdep/gui/PanelHD.cpp src/osdep/gui/PanelHD.cpp
--- src_93/osdep/gui/PanelHD.cpp	2019-08-10 17:34:49.000000000 +0300
+++ src/osdep/gui/PanelHD.cpp	2019-08-10 17:37:32.260039266 +0300
@@ -431,7 +431,11 @@
   cboCDFile->addActionListener(cdFileActionListener);
 
 	lblCDVol = new gcn::Label("CD Volume:");
+#ifdef ANDROID
+  lblCDVol->setSize(85, LABEL_HEIGHT);
+#else
   lblCDVol->setSize(80, LABEL_HEIGHT);
+#endif
   lblCDVol->setAlignment(gcn::Graphics::RIGHT);
   sldCDVol = new gcn::Slider(0, 100);
   sldCDVol->setSize(200, SLIDER_HEIGHT);
@@ -532,15 +536,15 @@
   helptext.clear();
   helptext.push_back("Use \"Add Directory\" to add a folder or \"Add Hardfile\" to add a HDF file as a hard disk. To edit the settings of a");
   helptext.push_back("HDD, click on \"...\" left to the entry in the list. With the red cross, you can delete an entry.");
-  helptext.push_back("");
+  helptext.push_back(" ");
   helptext.push_back("With \"Create Hardfile\", you can create a new formatted HDF file up to 2 GB. For large files, it will take some time");
   helptext.push_back("to create the new hard disk. You have to format the new HDD in the Amiga via the Workbench.");
-  helptext.push_back("");
+  helptext.push_back(" ");
   helptext.push_back("If \"Master harddrive write protection\" is activated, you can't write to any HD.");
-  helptext.push_back("");
+  helptext.push_back(" ");
   helptext.push_back("Activate \"CD drive\" to emulate CD for CD32. Use \"Eject\" to remove current CD and click on \"...\" to open a dialog");
   helptext.push_back("to select the iso/cue file for CD emulation.");
-  helptext.push_back("");
+  helptext.push_back(" ");
   helptext.push_back("In current version, WAV, MP3 and FLAC is supported for audio tracks.");
   helptext.push_back("The audio volume of the CD can be adjusted with \"CD Volume\".");
   return true;
diff -Nru src_93/osdep/gui/PanelInput.cpp src/osdep/gui/PanelInput.cpp
--- src_93/osdep/gui/PanelInput.cpp	2019-08-10 17:34:49.000000000 +0300
+++ src/osdep/gui/PanelInput.cpp	2019-08-10 17:37:32.260039266 +0300
@@ -278,7 +278,11 @@
   scrAreaList = new gcn::ScrollArea(lstWidget);
   scrAreaList->setFrameSize(1);
   scrAreaList->setSize(listViewWidth, listViewHeight);
+#ifdef ANDROID
+  scrAreaList->setScrollbarWidth(30);
+#else
   scrAreaList->setScrollbarWidth(20);
+#endif
   scrAreaList->setBaseColor(gui_baseCol + 0x202020);
   
   ctrlAmigaList = new gcn::GenericListModel(amigalist, 1);
@@ -350,7 +354,7 @@
   helptext.clear();
   helptext.push_back("Select the device first, for which you want to change the default mapping. Then select the line of the available");
   helptext.push_back("button/axis in the list you want to remap.");
-  helptext.push_back("");
+  helptext.push_back(" ");
   helptext.push_back("Choose the new target action in the dropdown control \"Target\" for the current selected entry.");
   return true;
 }
diff -Nru src_93/osdep/gui/PanelMisc.cpp src/osdep/gui/PanelMisc.cpp
--- src_93/osdep/gui/PanelMisc.cpp	2019-08-10 17:34:49.000000000 +0300
+++ src/osdep/gui/PanelMisc.cpp	2019-08-10 17:37:32.260039266 +0300
@@ -24,6 +24,10 @@
 #include "gui.h"
 #include "gui_handling.h"
 
+#ifdef ANDROID
+#undef PANDORA
+#endif
+
 
 static gcn::UaeCheckBox* chkStatusLine;
 static gcn::UaeCheckBox* chkStatusLineRTG;
@@ -262,17 +266,17 @@
   helptext.push_back("The first value in the status line shows the idle time of the host CPU in %, the second value is the current frame");
   helptext.push_back("rate. When you have a HDD in your Amiga emulation, the HD indicator shows read (blue) and write (red) access");
   helptext.push_back("to the HDD. The next values are showing the track number for each disk drive and indicates disk access.");
-  helptext.push_back("");
+  helptext.push_back(" ");
   helptext.push_back("When you deactivate the option \"Show GUI on startup\" and use this configuration by specifying it with the");
   helptext.push_back("command line parameter \"-config=<file>\", the emulation starts directly without showing the GUI.");
-  helptext.push_back("");
+  helptext.push_back(" ");
 #ifdef PANDORA
   helptext.push_back("Set the speed for the Pandora CPU to overclock it for games which need more power. Be careful with this");
   helptext.push_back("parameter.");
-  helptext.push_back("");
+  helptext.push_back(" ");
 #endif	
   helptext.push_back("\"bsdsocket.library\" enables network functions (i.e. for web browsers in OS3.9).");
-  helptext.push_back("");
+  helptext.push_back(" ");
   helptext.push_back("\"Master floppy drive protection\" will disable all write access to floppy disks.");
   return true;
 }
diff -Nru src_93/osdep/gui/PanelOnScreen.cpp src/osdep/gui/PanelOnScreen.cpp
--- src_93/osdep/gui/PanelOnScreen.cpp	1970-01-01 03:00:00.000000000 +0300
+++ src/osdep/gui/PanelOnScreen.cpp	2019-08-10 17:37:32.268039006 +0300
@@ -0,0 +1,443 @@
+#include <guichan.hpp>
+#include <SDL/SDL_ttf.h>
+#include <guichan/sdl.hpp>
+#include "sdltruetypefont.hpp"
+#include "SelectorEntry.hpp"
+#include "UaeRadioButton.hpp"
+#include "UaeDropDown.hpp"
+#include "UaeCheckBox.hpp"
+
+#include "sysconfig.h"
+#include "sysdeps.h"
+#include "config.h"
+#include "options.h"
+#include "gui_handling.h"
+
+
+static gcn::UaeCheckBox* checkBox_onscreen_control;
+static gcn::UaeCheckBox* checkBox_onscreen_textinput;
+static gcn::UaeCheckBox* checkBox_onscreen_dpad;
+static gcn::UaeCheckBox* checkBox_onscreen_button1;
+static gcn::UaeCheckBox* checkBox_onscreen_button2;
+static gcn::UaeCheckBox* checkBox_onscreen_button3;
+static gcn::UaeCheckBox* checkBox_onscreen_button4;
+static gcn::UaeCheckBox* checkBox_onscreen_button5;
+static gcn::UaeCheckBox* checkBox_onscreen_button6;
+static gcn::UaeCheckBox* checkBox_onscreen_custompos;
+static gcn::UaeCheckBox* checkBox_floatingJoystick;
+static gcn::UaeCheckBox* checkBox_disableMenuVKeyb;
+static gcn::Button* button_onscreen_pos;
+static gcn::Button* button_onscreen_ok;
+static gcn::Button* button_onscreen_reset;
+static gcn::Window *window_setup_position;
+static gcn::Window *window_pos_textinput;
+static gcn::Window *window_pos_dpad;
+static gcn::Window *window_pos_button1;
+static gcn::Window *window_pos_button2;
+static gcn::Window *window_pos_button3;
+static gcn::Window *window_pos_button4;
+static gcn::Window *window_pos_button5;
+static gcn::Window *window_pos_button6;
+static gcn::Label* label_setup_onscreen;
+static gcn::TextField *textInput;
+
+static void RefreshPanelOnScreen(void)
+{
+    if (workprefs.onScreen==0)
+        checkBox_onscreen_control->setSelected(false);
+    else if (workprefs.onScreen==1)
+        checkBox_onscreen_control->setSelected(true);
+    if (workprefs.onScreen_textinput==0)
+        checkBox_onscreen_textinput->setSelected(false);
+    else if (workprefs.onScreen_textinput==1)
+        checkBox_onscreen_textinput->setSelected(true);
+    if (workprefs.onScreen_dpad==0)
+        checkBox_onscreen_dpad->setSelected(false);
+    else if (workprefs.onScreen_dpad==1)
+        checkBox_onscreen_dpad->setSelected(true);
+    if (workprefs.onScreen_button1==0)
+        checkBox_onscreen_button1->setSelected(false);
+    else if (workprefs.onScreen_button1==1)
+        checkBox_onscreen_button1->setSelected(true);
+    if (workprefs.onScreen_button2==0)
+        checkBox_onscreen_button2->setSelected(false);
+    else if (workprefs.onScreen_button2==1)
+        checkBox_onscreen_button2->setSelected(true);
+    if (workprefs.onScreen_button3==0)
+        checkBox_onscreen_button3->setSelected(false);
+    else if (workprefs.onScreen_button3==1)
+        checkBox_onscreen_button3->setSelected(true);
+    if (workprefs.onScreen_button4==0)
+        checkBox_onscreen_button4->setSelected(false);
+    else if (workprefs.onScreen_button4==1)
+        checkBox_onscreen_button4->setSelected(true);
+    if (workprefs.onScreen_button5==0)
+        checkBox_onscreen_button5->setSelected(false);
+    else if (workprefs.onScreen_button5==1)
+        checkBox_onscreen_button5->setSelected(true);
+    if (workprefs.onScreen_button6==0)
+        checkBox_onscreen_button6->setSelected(false);
+    else if (workprefs.onScreen_button6==1)
+        checkBox_onscreen_button6->setSelected(true);
+    if (workprefs.custom_position==0)
+        checkBox_onscreen_custompos->setSelected(false);
+    else if (workprefs.custom_position==1)
+        checkBox_onscreen_custompos->setSelected(true);
+    if (workprefs.floatingJoystick)
+        checkBox_floatingJoystick->setSelected(true);
+    else
+        checkBox_floatingJoystick->setSelected(false);
+    if (workprefs.disableMenuVKeyb)
+        checkBox_disableMenuVKeyb->setSelected(true);
+    else
+        checkBox_disableMenuVKeyb->setSelected(false);
+    
+    textInput->disableVirtualKeyboard(workprefs.disableMenuVKeyb);
+    
+    window_pos_textinput->setX(workprefs.pos_x_textinput);
+    window_pos_textinput->setY(workprefs.pos_y_textinput);
+    window_pos_textinput->setVisible(workprefs.onScreen_textinput);
+    window_pos_dpad->setX(workprefs.pos_x_dpad);
+    window_pos_dpad->setY(workprefs.pos_y_dpad);
+    window_pos_dpad->setVisible(workprefs.onScreen_dpad);
+    window_pos_button1->setX(workprefs.pos_x_button1);
+    window_pos_button1->setY(workprefs.pos_y_button1);
+    window_pos_button1->setVisible(workprefs.onScreen_button1);
+    window_pos_button2->setX(workprefs.pos_x_button2);
+    window_pos_button2->setY(workprefs.pos_y_button2);
+    window_pos_button2->setVisible(workprefs.onScreen_button2);
+    window_pos_button3->setX(workprefs.pos_x_button3);
+    window_pos_button3->setY(workprefs.pos_y_button3);
+    window_pos_button3->setVisible(workprefs.onScreen_button3);
+    window_pos_button4->setX(workprefs.pos_x_button4);
+    window_pos_button4->setY(workprefs.pos_y_button4);
+    window_pos_button4->setVisible(workprefs.onScreen_button4);
+    window_pos_button5->setX(workprefs.pos_x_button5);
+    window_pos_button5->setY(workprefs.pos_y_button5);
+    window_pos_button5->setVisible(workprefs.onScreen_button5);
+    window_pos_button6->setX(workprefs.pos_x_button6);
+    window_pos_button6->setY(workprefs.pos_y_button6);
+    window_pos_button6->setVisible(workprefs.onScreen_button6);
+    button_onscreen_pos->setVisible(workprefs.custom_position);
+}
+
+class OnScreenActionListener : public gcn::ActionListener
+{
+  public:
+    void action(const gcn::ActionEvent& actionEvent)
+    {
+        if (actionEvent.getSource() == checkBox_onscreen_control) {
+            if (checkBox_onscreen_control->isSelected())
+                workprefs.onScreen=1;
+            else
+                workprefs.onScreen=0;
+        }
+        if (actionEvent.getSource() == checkBox_onscreen_textinput) {
+            if (checkBox_onscreen_textinput->isSelected())
+                workprefs.onScreen_textinput=1;
+            else
+                workprefs.onScreen_textinput=0;
+        }
+        if (actionEvent.getSource() == checkBox_onscreen_dpad) {
+            if (checkBox_onscreen_dpad->isSelected())
+                workprefs.onScreen_dpad=1;
+            else
+                workprefs.onScreen_dpad=0;
+        }
+        if (actionEvent.getSource() == checkBox_onscreen_button1) {
+            if (checkBox_onscreen_button1->isSelected())
+                workprefs.onScreen_button1=1;
+            else
+                workprefs.onScreen_button1=0;
+        }
+        if (actionEvent.getSource() == checkBox_onscreen_button2) {
+            if (checkBox_onscreen_button2->isSelected())
+                workprefs.onScreen_button2=1;
+            else
+                workprefs.onScreen_button2=0;
+        }
+        if (actionEvent.getSource() == checkBox_onscreen_button3) {
+            if (checkBox_onscreen_button3->isSelected())
+                workprefs.onScreen_button3=1;
+            else
+                workprefs.onScreen_button3=0;
+        }
+        if (actionEvent.getSource() == checkBox_onscreen_button4) {
+            if (checkBox_onscreen_button4->isSelected())
+                workprefs.onScreen_button4=1;
+            else
+                workprefs.onScreen_button4=0;
+        }
+        if (actionEvent.getSource() == checkBox_onscreen_button5) {
+            if (checkBox_onscreen_button5->isSelected())
+                workprefs.onScreen_button5=1;
+            else
+                workprefs.onScreen_button5=0;
+        }
+        if (actionEvent.getSource() == checkBox_onscreen_button6) {
+            if (checkBox_onscreen_button6->isSelected())
+                workprefs.onScreen_button6=1;
+            else
+                workprefs.onScreen_button6=0;
+        }
+        if (actionEvent.getSource() == checkBox_onscreen_custompos) {
+            if (checkBox_onscreen_custompos->isSelected())
+                workprefs.custom_position=1;
+            else
+                workprefs.custom_position=0;
+        }
+        if (actionEvent.getSource() == checkBox_floatingJoystick)
+            if (checkBox_floatingJoystick->isSelected())
+                workprefs.floatingJoystick=1;
+            else
+                workprefs.floatingJoystick=0;
+        if (actionEvent.getSource() == checkBox_disableMenuVKeyb)
+            if (checkBox_disableMenuVKeyb->isSelected())
+                workprefs.disableMenuVKeyb=1;
+            else
+                workprefs.disableMenuVKeyb=0;
+        RefreshPanelOnScreen();
+    }
+};
+static OnScreenActionListener* onScreenActionListener;
+
+class SetupPosButtonActionListener : public gcn::ActionListener
+{
+public:
+    void action(const gcn::ActionEvent& actionEvent) {
+        if (actionEvent.getSource() == button_onscreen_pos)
+            window_setup_position->setVisible(true);
+        RefreshPanelOnScreen();
+    }
+};
+static SetupPosButtonActionListener* setupPosButtonActionListener;
+
+class WindowPosButtonActionListener : public gcn::ActionListener
+{
+public:
+    void action(const gcn::ActionEvent& actionEvent) {
+        if (actionEvent.getSource() == button_onscreen_ok) {
+            workprefs.pos_x_textinput = window_pos_textinput->getX();
+            workprefs.pos_y_textinput = window_pos_textinput->getY();
+            workprefs.pos_x_dpad = window_pos_dpad->getX();
+            workprefs.pos_y_dpad = window_pos_dpad->getY();
+            workprefs.pos_x_button1 = window_pos_button1->getX();
+            workprefs.pos_y_button1 = window_pos_button1->getY();
+            workprefs.pos_x_button2 = window_pos_button2->getX();
+            workprefs.pos_y_button2 = window_pos_button2->getY();
+            workprefs.pos_x_button3 = window_pos_button3->getX();
+            workprefs.pos_y_button3 = window_pos_button3->getY();
+            workprefs.pos_x_button4 = window_pos_button4->getX();
+            workprefs.pos_y_button4 = window_pos_button4->getY();
+            workprefs.pos_x_button5 = window_pos_button5->getX();
+            workprefs.pos_y_button5 = window_pos_button5->getY();
+            workprefs.pos_x_button6 = window_pos_button6->getX();
+            workprefs.pos_y_button6 = window_pos_button6->getY();
+            window_setup_position->setVisible(false);
+        }
+        if (actionEvent.getSource() == button_onscreen_reset) {
+            workprefs.pos_x_textinput = 0;
+            workprefs.pos_y_textinput = 0;
+            workprefs.pos_x_dpad = 4;
+            workprefs.pos_y_dpad = 215;
+            workprefs.pos_x_button1 = 430;
+            workprefs.pos_y_button1 = 286;
+            workprefs.pos_x_button2 = 378;
+            workprefs.pos_y_button2 = 286;
+            workprefs.pos_x_button3 = 430;
+            workprefs.pos_y_button3 = 214;
+            workprefs.pos_x_button4 = 378;
+            workprefs.pos_y_button4 = 214;
+            workprefs.pos_x_button5 = 430;
+            workprefs.pos_y_button5 = 142;
+            workprefs.pos_x_button6 = 378;
+            workprefs.pos_y_button6 = 142;
+            window_setup_position->setVisible(false);
+        }
+    }
+};
+static WindowPosButtonActionListener* windowPosButtonActionListener;
+
+void InitPanelOnScreen(const struct _ConfigCategory& category)
+{
+    onScreenActionListener = new OnScreenActionListener();
+    checkBox_onscreen_control = new gcn::UaeCheckBox("On-screen control");
+    checkBox_onscreen_control->setPosition(10,20);
+    checkBox_onscreen_control->setId("OnScrCtrl");
+    checkBox_onscreen_control->addActionListener(onScreenActionListener);
+    checkBox_onscreen_textinput = new gcn::UaeCheckBox("TextInput button");
+    checkBox_onscreen_textinput->setPosition(10,50);
+    checkBox_onscreen_textinput->setId("OnScrTextInput");
+    checkBox_onscreen_textinput->addActionListener(onScreenActionListener);
+    checkBox_onscreen_dpad = new gcn::UaeCheckBox("D-pad");
+    checkBox_onscreen_dpad->setPosition(10,80);
+    checkBox_onscreen_dpad->setId("OnScrDpad");
+    checkBox_onscreen_dpad->addActionListener(onScreenActionListener);
+    checkBox_onscreen_button1 = new gcn::UaeCheckBox("Button 1 <A>");
+    checkBox_onscreen_button1->setPosition(10,110);
+    checkBox_onscreen_button1->setId("OnScrButton1");
+    checkBox_onscreen_button1->addActionListener(onScreenActionListener);
+    checkBox_onscreen_button2 = new gcn::UaeCheckBox("Button 2 <B>");
+    checkBox_onscreen_button2->setPosition(10,140);
+    checkBox_onscreen_button2->setId("OnScrButton2");
+    checkBox_onscreen_button2->addActionListener(onScreenActionListener);
+    checkBox_onscreen_button3 = new gcn::UaeCheckBox("Button 3 <X>");
+    checkBox_onscreen_button3->setPosition(170,20);
+    checkBox_onscreen_button3->setId("OnScrButton3");
+    checkBox_onscreen_button3->addActionListener(onScreenActionListener);
+    checkBox_onscreen_button4 = new gcn::UaeCheckBox("Button 4 <Y>");
+    checkBox_onscreen_button4->setPosition(170,50);
+    checkBox_onscreen_button4->setId("OnScrButton4");
+    checkBox_onscreen_button4->addActionListener(onScreenActionListener);
+    checkBox_onscreen_button5 = new gcn::UaeCheckBox("Button 5 <R>");
+    checkBox_onscreen_button5->setPosition(170,80);
+    checkBox_onscreen_button5->setId("OnScrButton5");
+    checkBox_onscreen_button5->addActionListener(onScreenActionListener);
+    checkBox_onscreen_button6 = new gcn::UaeCheckBox("Button 6 <L>");
+    checkBox_onscreen_button6->setPosition(170,110);
+    checkBox_onscreen_button6->setId("OnScrButton6");
+    checkBox_onscreen_button6->addActionListener(onScreenActionListener);
+    checkBox_onscreen_custompos = new gcn::UaeCheckBox("Custom position");
+    checkBox_onscreen_custompos->setPosition(170,140);
+    checkBox_onscreen_custompos->setId("CustomPos");
+    checkBox_onscreen_custompos->addActionListener(onScreenActionListener);
+    checkBox_floatingJoystick = new gcn::UaeCheckBox("Floating Joystick");
+    checkBox_floatingJoystick->setPosition(10,180);
+    checkBox_floatingJoystick->setId("FloatJoy");
+    checkBox_floatingJoystick->addActionListener(onScreenActionListener);
+    checkBox_disableMenuVKeyb = new gcn::UaeCheckBox("Disable virtual keyboard in menu");
+    checkBox_disableMenuVKeyb->setPosition(10,210);
+    checkBox_disableMenuVKeyb->setId("DisableMenuVKeyb");
+    checkBox_disableMenuVKeyb->addActionListener(onScreenActionListener);
+
+    button_onscreen_pos = new gcn::Button("Position Setup");
+    button_onscreen_pos->setPosition(170,180);
+    button_onscreen_pos->setBaseColor(gui_baseCol);
+    setupPosButtonActionListener = new SetupPosButtonActionListener();
+    button_onscreen_pos->addActionListener(setupPosButtonActionListener);
+
+    button_onscreen_ok = new gcn::Button(" Ok ");
+    button_onscreen_ok->setPosition(220,175);
+    button_onscreen_ok->setBaseColor(gui_baseCol);
+    button_onscreen_reset = new gcn::Button(" Reset Position to default ");
+    button_onscreen_reset->setPosition(150,105);
+    button_onscreen_reset->setBaseColor(gui_baseCol);
+    windowPosButtonActionListener = new WindowPosButtonActionListener();
+    button_onscreen_ok->addActionListener(windowPosButtonActionListener);
+    button_onscreen_reset->addActionListener(windowPosButtonActionListener);
+    label_setup_onscreen = new gcn::Label("Try drag and drop window then press ok");
+    label_setup_onscreen->setPosition(100,140);
+	
+	textInput = new gcn::TextField();
+//    label_setup_onscreen->setFont(font14);
+
+    window_pos_textinput = new gcn::Window("Ab");
+    window_pos_textinput->setMovable(true);
+    window_pos_textinput->setSize(25,30);
+    window_pos_textinput->setBaseColor(gui_baseCol);
+    window_pos_dpad = new gcn::Window("Dpad");
+    window_pos_dpad->setMovable(true);
+    window_pos_dpad->setSize(100,130);
+    window_pos_dpad->setBaseColor(gui_baseCol);
+    window_pos_button1 = new gcn::Window("1<A>");
+    window_pos_button1->setMovable(true);
+    window_pos_button1->setSize(50,65);
+    window_pos_button1->setBaseColor(gui_baseCol);
+    window_pos_button2 = new gcn::Window("2<B>");
+    window_pos_button2->setMovable(true);
+    window_pos_button2->setSize(50,65);
+    window_pos_button2->setBaseColor(gui_baseCol);
+    window_pos_button3 = new gcn::Window("3<X>");
+    window_pos_button3->setMovable(true);
+    window_pos_button3->setSize(50,65);
+    window_pos_button3->setBaseColor(gui_baseCol);
+    window_pos_button4 = new gcn::Window("4<Y>");
+    window_pos_button4->setMovable(true);
+    window_pos_button4->setSize(50,65);
+    window_pos_button4->setBaseColor(gui_baseCol);
+    window_pos_button5 = new gcn::Window("5<R>");
+    window_pos_button5->setMovable(true);
+    window_pos_button5->setSize(50,65);
+    window_pos_button5->setBaseColor(gui_baseCol);
+    window_pos_button6 = new gcn::Window("6<L>");
+    window_pos_button6->setMovable(true);
+    window_pos_button6->setSize(50,65);
+    window_pos_button6->setBaseColor(gui_baseCol);
+
+    window_setup_position = new gcn::Window("Setup position");
+    window_setup_position->setPosition(60,20);
+    window_setup_position->add(label_setup_onscreen);
+    window_setup_position->add(button_onscreen_ok);
+    window_setup_position->add(button_onscreen_reset);
+    window_setup_position->add(window_pos_textinput);
+    window_setup_position->add(window_pos_dpad);
+    window_setup_position->add(window_pos_button1);
+    window_setup_position->add(window_pos_button2);
+    window_setup_position->add(window_pos_button3);
+    window_setup_position->add(window_pos_button4);
+    window_setup_position->add(window_pos_button5);
+    window_setup_position->add(window_pos_button6);
+    window_setup_position->setMovable(false);
+    window_setup_position->setSize(485,370);   
+    window_setup_position->setVisible(false);
+    
+    category.panel->add(checkBox_onscreen_control);
+    category.panel->add(checkBox_onscreen_textinput);
+    category.panel->add(checkBox_onscreen_dpad);
+    category.panel->add(checkBox_onscreen_button1);
+    category.panel->add(checkBox_onscreen_button2);
+    category.panel->add(checkBox_onscreen_button3);
+    category.panel->add(checkBox_onscreen_button4);
+    category.panel->add(checkBox_onscreen_button5);
+    category.panel->add(checkBox_onscreen_button6);
+    category.panel->add(checkBox_onscreen_custompos);
+    category.panel->add(checkBox_floatingJoystick);
+    category.panel->add(checkBox_disableMenuVKeyb);
+    category.panel->add(button_onscreen_pos);
+    category.panel->add(window_setup_position);
+    
+  RefreshPanelOnScreen();
+}
+
+
+void ExitPanelOnScreen(const struct _ConfigCategory& category)
+{
+	category.panel->clear();
+	
+    delete checkBox_onscreen_control;
+    delete checkBox_onscreen_textinput;
+    delete checkBox_onscreen_dpad;
+    delete checkBox_onscreen_button1;
+    delete checkBox_onscreen_button2;
+    delete checkBox_onscreen_button3;
+    delete checkBox_onscreen_button4;
+    delete checkBox_onscreen_button5;
+    delete checkBox_onscreen_button6;
+    delete checkBox_onscreen_custompos;
+    delete checkBox_floatingJoystick;
+    delete checkBox_disableMenuVKeyb;
+    delete button_onscreen_pos;
+    delete button_onscreen_ok;
+    delete button_onscreen_reset;
+    delete window_setup_position;
+    delete window_pos_textinput;
+    delete window_pos_dpad;
+    delete window_pos_button1;
+    delete window_pos_button2;
+    delete window_pos_button3;
+    delete window_pos_button4;
+    delete window_pos_button5;
+    delete window_pos_button6;
+    delete label_setup_onscreen;
+	delete textInput;
+  delete setupPosButtonActionListener;
+  delete windowPosButtonActionListener;
+  delete onScreenActionListener;
+}
+
+bool HelpPanelOnScreen(std::vector<std::string> &helptext)
+{
+  helptext.clear();
+  helptext.push_back("onScreen Help");
+  return true;
+}
diff -Nru src_93/osdep/gui/PanelPaths.cpp src/osdep/gui/PanelPaths.cpp
--- src_93/osdep/gui/PanelPaths.cpp	2019-01-03 19:49:41.000000000 +0200
+++ src/osdep/gui/PanelPaths.cpp	2019-08-10 17:37:32.268039006 +0300
@@ -149,7 +149,7 @@
   helptext.clear();
   helptext.push_back("Specify the location of your kickstart roms and the folder where the configuration files should be stored.");
   helptext.push_back("Use the \"...\" button to open a dialog to choose the folder.");
-  helptext.push_back("");
+  helptext.push_back(" ");
   helptext.push_back("After changing the location of the kickstart roms, click on \"Rescan ROMS\" to refresh the list of the available");
   helptext.push_back("ROMs.");
   return true;
diff -Nru src_93/osdep/gui/PanelQuickstart.cpp src/osdep/gui/PanelQuickstart.cpp
--- src_93/osdep/gui/PanelQuickstart.cpp	2019-08-10 17:34:49.000000000 +0300
+++ src/osdep/gui/PanelQuickstart.cpp	2019-08-10 17:37:32.268039006 +0300
@@ -66,23 +66,38 @@
 	     "Basic non-expanded configuration",
 	     "2 MB Chip RAM expanded configuration",
 	     "4 MB Fast RAM expanded configuration",
+#ifdef ANDROID
+         " ", " ", " ",
+#endif
 	     "\0" } },
 	{ "Amiga 600", { 
 	     "Basic non-expanded configuration",
 	     "2 MB Chip RAM expanded configuration",
 	     "4 MB Fast RAM expanded configuration",
+#ifdef ANDROID
+         " ", " ", " ",
+#endif
 	     "\0" } },
 	{ "Amiga 1200", {
 	      "Basic non-expanded configuration",
 	      "4 MB Fast RAM expanded configuration",
+#ifdef ANDROID
+         " ", " ", " ", " ",
+#endif
 	      "\0" } },
 	{ "Amiga 4000", {
        "68030, 3.1 ROM, 2MB Chip + 8MB Fast",
        "68040, 3.1 ROM, 2MB Chip + 8MB Fast",
+#ifdef ANDROID
+         " ", " ", " ", " ",
+#endif
        "\0" } },
 	{ "CD32", { 
 	     "CD32", 
 	     "CD32 with Full Motion Video cartridge",
+#ifdef ANDROID
+         " ", " ", " ", " ",
+#endif
 	     "\0" } },
 	{ "\0" }
 };
@@ -658,7 +673,11 @@
 	for(i = 0; i < 2; ++i) {
 	  posX = DISTANCE_BORDER;
 	  category.panel->add(chkDFx[i], posX, posY);
+#ifdef ANDROID
+	  posX += 165;
+#else
 	  posX += 180;
+#endif
 	  category.panel->add(chkDFxWriteProtect[i], posX, posY);
 	  posX += chkDFxWriteProtect[i]->getWidth() + 4 * DISTANCE_NEXT_X;
 //	  category.panel->add(cmdDFxInfo[i], posX, posY);
@@ -729,10 +748,10 @@
 {
   helptext.clear();
   helptext.push_back("Simplified start of emulation by just selecting the Amiga model and the disk/CD you want to use.");
-  helptext.push_back("");
+  helptext.push_back(" ");
   helptext.push_back("After selecting the Amiga model, you can choose from a small list of standard configurations for this model to");
   helptext.push_back("start with.");
-  helptext.push_back("");
+  helptext.push_back(" ");
   helptext.push_back("When you activate \"Start in Quickstart mode\", the next time you run the emulator, it  will start with the quickstart");
   helptext.push_back("panel. Otherwise you start in configuraions panel.");
   return true;
diff -Nru src_93/osdep/gui/PanelRAM.cpp src/osdep/gui/PanelRAM.cpp
--- src_93/osdep/gui/PanelRAM.cpp	2019-08-10 17:34:49.000000000 +0300
+++ src/osdep/gui/PanelRAM.cpp	2019-08-10 17:37:32.268039006 +0300
@@ -177,12 +177,21 @@
 void InitPanelRAM(const struct _ConfigCategory& category)
 {
   memorySliderActionListener = new MemorySliderActionListener();
-  
+  int sldWidth;
+  int markerLength;
+#ifdef ANDROID
+  sldWidth = 150;
+  markerLength = 30;
+#else
+  sldWidth = 110;
+  markerLength = 20;
+#endif
+
 	lblChipmem = new gcn::Label("Chip:");
   sldChipmem = new gcn::Slider(0, 4);
-  sldChipmem->setSize(110, SLIDER_HEIGHT);
+  sldChipmem->setSize(sldWidth, SLIDER_HEIGHT);
   sldChipmem->setBaseColor(gui_baseCol);
-	sldChipmem->setMarkerLength(20);
+	sldChipmem->setMarkerLength(markerLength);
 	sldChipmem->setStepLength(1);
 	sldChipmem->setId("Chipmem");
   sldChipmem->addActionListener(memorySliderActionListener);
@@ -190,9 +199,9 @@
 
 	lblSlowmem = new gcn::Label("Slow:");
   sldSlowmem = new gcn::Slider(0, 4);
-  sldSlowmem->setSize(110, SLIDER_HEIGHT);
+  sldSlowmem->setSize(sldWidth, SLIDER_HEIGHT);
   sldSlowmem->setBaseColor(gui_baseCol);
-	sldSlowmem->setMarkerLength(20);
+	sldSlowmem->setMarkerLength(markerLength);
 	sldSlowmem->setStepLength(1);
 	sldSlowmem->setId("Slowmem");
   sldSlowmem->addActionListener(memorySliderActionListener);
@@ -200,9 +209,9 @@
 
 	lblFastmem = new gcn::Label("Z2 Fast:");
   sldFastmem = new gcn::Slider(0, 4);
-  sldFastmem->setSize(110, SLIDER_HEIGHT);
+  sldFastmem->setSize(sldWidth, SLIDER_HEIGHT);
   sldFastmem->setBaseColor(gui_baseCol);
-	sldFastmem->setMarkerLength(20);
+	sldFastmem->setMarkerLength(markerLength);
 	sldFastmem->setStepLength(1);
 	sldFastmem->setId("Fastmem");
   sldFastmem->addActionListener(memorySliderActionListener);
@@ -210,9 +219,9 @@
 
 	lblZ3mem = new gcn::Label("Z3 fast:");
   sldZ3mem = new gcn::Slider(0, 8);
-  sldZ3mem->setSize(110, SLIDER_HEIGHT);
+  sldZ3mem->setSize(sldWidth, SLIDER_HEIGHT);
   sldZ3mem->setBaseColor(gui_baseCol);
-	sldZ3mem->setMarkerLength(20);
+	sldZ3mem->setMarkerLength(markerLength);
 	sldZ3mem->setStepLength(1);
 	sldZ3mem->setId("Z3mem");
   sldZ3mem->addActionListener(memorySliderActionListener);
@@ -220,9 +229,9 @@
   
 	lblGfxmem = new gcn::Label("RTG board:");
   sldGfxmem = new gcn::Slider(0, 5);
-  sldGfxmem->setSize(110, SLIDER_HEIGHT);
+  sldGfxmem->setSize(sldWidth, SLIDER_HEIGHT);
   sldGfxmem->setBaseColor(gui_baseCol);
-	sldGfxmem->setMarkerLength(20);
+	sldGfxmem->setMarkerLength(markerLength);
 	sldGfxmem->setStepLength(1);
 	sldGfxmem->setId("Gfxmem");
   sldGfxmem->addActionListener(memorySliderActionListener);
@@ -230,9 +239,9 @@
 
 	lblA3000Lowmem = new gcn::Label("A4000 Motherb. slot:");
   sldA3000Lowmem = new gcn::Slider(0, 4);
-  sldA3000Lowmem->setSize(110, SLIDER_HEIGHT);
+  sldA3000Lowmem->setSize(sldWidth, SLIDER_HEIGHT);
   sldA3000Lowmem->setBaseColor(gui_baseCol);
-	sldA3000Lowmem->setMarkerLength(20);
+	sldA3000Lowmem->setMarkerLength(markerLength);
 	sldA3000Lowmem->setStepLength(1);
 	sldA3000Lowmem->setId("A3000Low");
   sldA3000Lowmem->addActionListener(memorySliderActionListener);
@@ -240,9 +249,9 @@
 
 	lblA3000Highmem = new gcn::Label("A4000 Proc. board:");
   sldA3000Highmem = new gcn::Slider(0, 5);
-  sldA3000Highmem->setSize(110, SLIDER_HEIGHT);
+  sldA3000Highmem->setSize(sldWidth, SLIDER_HEIGHT);
   sldA3000Highmem->setBaseColor(gui_baseCol);
-	sldA3000Highmem->setMarkerLength(20);
+	sldA3000Highmem->setMarkerLength(markerLength);
 	sldA3000Highmem->setStepLength(1);
 	sldA3000Highmem->setId("A3000High");
   sldA3000Highmem->addActionListener(memorySliderActionListener);
@@ -290,7 +299,11 @@
 	posY += sldA3000Highmem->getHeight() + DISTANCE_NEXT_Y;
 
 	grpRAM->setMovable(false);
+#ifdef ANDROID
+	grpRAM->setSize(400, posY + DISTANCE_BORDER);
+#else
 	grpRAM->setSize(350, posY + DISTANCE_BORDER);
+#endif
   grpRAM->setBaseColor(gui_baseCol);
   
   category.panel->add(grpRAM);
diff -Nru src_93/osdep/gui/PanelROM.cpp src/osdep/gui/PanelROM.cpp
--- src_93/osdep/gui/PanelROM.cpp	2019-08-10 17:34:49.000000000 +0300
+++ src/osdep/gui/PanelROM.cpp	2019-08-10 17:37:32.268039006 +0300
@@ -78,7 +78,7 @@
       int currIdx = -1;
       if(ROMType & (ROMTYPE_ALL_EXT | ROMTYPE_ALL_CART))
       {
-        roms.push_back(""); 
+        roms.push_back(" "); 
         idxToAvailableROMs.push_back(-1);
         currIdx = 0;
       }
@@ -145,7 +145,7 @@
         if(rom != NULL)
           strncpy(workprefs.romextfile, rom->Path, sizeof(workprefs.romextfile) - 1);
         else
-          strncpy(workprefs.romextfile, "", sizeof(workprefs.romextfile) - 1);
+          strncpy(workprefs.romextfile, " ", sizeof(workprefs.romextfile) - 1);
 
 #ifdef ACTION_REPLAY
       } else if (actionEvent.getSource() == cboCartROM) {
@@ -153,7 +153,7 @@
         if(rom != NULL)
           strncpy(workprefs.cartfile, rom->Path, sizeof(workprefs.cartfile) - 1);
         else
-          strncpy(workprefs.cartfile, "", sizeof(workprefs.cartfile) - 1);
+          strncpy(workprefs.cartfile, " ", sizeof(workprefs.cartfile) - 1);
 #endif
 
       } else if (actionEvent.getSource() == cmdMainROM) {
@@ -230,11 +230,16 @@
 #ifdef ACTION_REPLAY
   cartROMList = new ROMListModel(ROMTYPE_ALL_CART);
 #endif
-  
+  int cboWidth;
+#ifdef ANDROID
+  cboWidth = 450;
+#else
+  cboWidth = 400;
+#endif
   lblMainROM = new gcn::Label("Main ROM File:");
   lblMainROM->setSize(200, LABEL_HEIGHT);
 	cboMainROM = new gcn::UaeDropDown(mainROMList);
-  cboMainROM->setSize(400, DROPDOWN_HEIGHT);
+  cboMainROM->setSize(cboWidth, DROPDOWN_HEIGHT);
   cboMainROM->setBaseColor(gui_baseCol);
   cboMainROM->setId("cboMainROM");
   cboMainROM->addActionListener(romActionListener);
@@ -247,7 +252,7 @@
   lblExtROM = new gcn::Label("Extended ROM File:");
   lblExtROM->setSize(200, LABEL_HEIGHT);
 	cboExtROM = new gcn::UaeDropDown(extROMList);
-  cboExtROM->setSize(400, DROPDOWN_HEIGHT);
+  cboExtROM->setSize(cboWidth, DROPDOWN_HEIGHT);
   cboExtROM->setBaseColor(gui_baseCol);
   cboExtROM->setId("cboExtROM");
   cboExtROM->addActionListener(romActionListener);
@@ -261,7 +266,7 @@
   lblCartROM = new gcn::Label("Cartridge ROM File:");
   lblCartROM->setSize(200, LABEL_HEIGHT);
 	cboCartROM = new gcn::UaeDropDown(cartROMList);
-  cboCartROM->setSize(400, DROPDOWN_HEIGHT);
+  cboCartROM->setSize(cboWidth, DROPDOWN_HEIGHT);
   cboCartROM->setBaseColor(gui_baseCol);
   cboCartROM->setId("cboCartROM");
   cboCartROM->addActionListener(romActionListener);
@@ -273,9 +278,9 @@
 #endif
 
   lblUAEROM = new gcn::Label("Advanced UAE expansion board/Boot ROM:");
-  lblUAEROM->setSize(400, LABEL_HEIGHT);
+  lblUAEROM->setSize(cboWidth, LABEL_HEIGHT);
 	cboUAEROM = new gcn::UaeDropDown(&uaeROMList);
-  cboUAEROM->setSize(400, DROPDOWN_HEIGHT);
+  cboUAEROM->setSize(cboWidth, DROPDOWN_HEIGHT);
   cboUAEROM->setBaseColor(gui_baseCol);
   cboUAEROM->setId("cboUAEROM");
   cboUAEROM->addActionListener(romActionListener);
@@ -294,6 +299,8 @@
   posY += cboExtROM->getHeight() + DISTANCE_NEXT_Y;
   
 #ifdef ACTION_REPLAY
+
+
   category.panel->add(lblCartROM, DISTANCE_BORDER, posY);
   posY += lblCartROM->getHeight() + 4;
   category.panel->add(cboCartROM, DISTANCE_BORDER, posY);
@@ -342,9 +349,9 @@
 {
   helptext.clear();
   helptext.push_back("Select the required kickstart ROM for the Amiga you want to emulate in \"Main ROM File\".");
-  helptext.push_back("");
+  helptext.push_back(" ");
   helptext.push_back("In \"Extended ROM File\", you can only select the required ROM for CD32 emulation.");
-  helptext.push_back("");
+  helptext.push_back(" ");
   helptext.push_back("In \"Cartridge ROM File\", you can select the CD32 FMV module to activate video playback in CD32.");
   helptext.push_back("There are also some Action Replay and Freezer cards and the built in HRTMon available.");
   helptext.push_back("");
diff -Nru src_93/osdep/gui/PanelSavestate.cpp src/osdep/gui/PanelSavestate.cpp
--- src_93/osdep/gui/PanelSavestate.cpp	2019-08-10 17:34:49.000000000 +0300
+++ src/osdep/gui/PanelSavestate.cpp	2019-08-10 17:37:32.268039006 +0300
@@ -257,11 +257,11 @@
   helptext.clear();
   helptext.push_back("Savestates are stored with the name of the disk in drive DF0 attached with the selected number.");
 #ifdef PANDORA
-  helptext.push_back("");
+  helptext.push_back(" ");
   helptext.push_back("When you hold left shoulder button and press 'l' during emulation, the state of the last active number will be");
   helptext.push_back("loaded. Hold left shoulder button and press 's' to save the current state in the last active slot.");
 #endif
-  helptext.push_back("");
+  helptext.push_back(" ");
   helptext.push_back("Note: Savestates with HDDs may not work.");
   return true;
 }
diff -Nru src_93/osdep/gui/PanelSound.cpp src/osdep/gui/PanelSound.cpp
--- src_93/osdep/gui/PanelSound.cpp	2019-08-10 17:34:49.000000000 +0300
+++ src/osdep/gui/PanelSound.cpp	2019-08-10 17:37:32.268039006 +0300
@@ -279,11 +279,22 @@
 	grpSound->add(optSoundEmulated, 5, 70);
 	grpSound->add(optSoundEmulatedBest, 5, 100);
 	grpSound->setMovable(false);
+#ifdef ANDROID
+	grpSound->setSize(210, 150);
+#else
 	grpSound->setSize(200, 150);
+#endif
   grpSound->setBaseColor(gui_baseCol);
 
+    int labelWidth;
+#ifdef ANDROID
+	labelWidth = 135;
+#else
+	labelWidth = 130;
+#endif
+
 	lblFrequency = new gcn::Label("Frequency:");
-	lblFrequency->setSize(130, LABEL_HEIGHT);
+	lblFrequency->setSize(labelWidth, LABEL_HEIGHT);
   lblFrequency->setAlignment(gcn::Graphics::RIGHT);
   cboFrequency = new gcn::UaeDropDown(&frequencyTypeList);
   cboFrequency->setSize(160, DROPDOWN_HEIGHT);
@@ -301,11 +312,15 @@
 	grpMode->add(optMono, 5, 10);
 	grpMode->add(optStereo, 5, 40);
 	grpMode->setMovable(false);
+#ifdef ANDROID
+	grpMode->setSize(95, 90);
+#else
 	grpMode->setSize(90, 90);
+#endif
   grpMode->setBaseColor(gui_baseCol);
 
 	lblInterpolation = new gcn::Label("Interpolation:");
-	lblInterpolation->setSize(130, LABEL_HEIGHT);
+	lblInterpolation->setSize(labelWidth, LABEL_HEIGHT);
   lblInterpolation->setAlignment(gcn::Graphics::RIGHT);
   cboInterpolation = new gcn::UaeDropDown(&interpolationTypeList);
   cboInterpolation->setSize(160, DROPDOWN_HEIGHT);
@@ -314,7 +329,7 @@
   cboInterpolation->addActionListener(soundActionListener);
 
 	lblFilter = new gcn::Label("Filter:");
-	lblFilter->setSize(130, LABEL_HEIGHT);
+	lblFilter->setSize(labelWidth, LABEL_HEIGHT);
   lblFilter->setAlignment(gcn::Graphics::RIGHT);
   cboFilter = new gcn::UaeDropDown(&filterTypeList);
   cboFilter->setSize(160, DROPDOWN_HEIGHT);
@@ -323,7 +338,7 @@
   cboFilter->addActionListener(soundActionListener);
 
 	lblSeparation = new gcn::Label("Stereo separation:");
-	lblSeparation->setSize(130, LABEL_HEIGHT);
+	lblSeparation->setSize(labelWidth, LABEL_HEIGHT);
   lblSeparation->setAlignment(gcn::Graphics::RIGHT);
   sldSeparation = new gcn::Slider(0, 10);
   sldSeparation->setSize(160, SLIDER_HEIGHT);
@@ -335,7 +350,7 @@
   lblSeparationInfo = new gcn::Label("100%");
 
 	lblStereoDelay = new gcn::Label("Stereo delay:");
-	lblStereoDelay->setSize(130, LABEL_HEIGHT);
+	lblStereoDelay->setSize(labelWidth, LABEL_HEIGHT);
   lblStereoDelay->setAlignment(gcn::Graphics::RIGHT);
   sldStereoDelay = new gcn::Slider(0, 10);
   sldStereoDelay->setSize(160, SLIDER_HEIGHT);
@@ -347,7 +362,7 @@
   lblStereoDelayInfo = new gcn::Label("10");
   
 	lblPaulaVol = new gcn::Label("Paula Volume:");
-  lblPaulaVol->setSize(130, LABEL_HEIGHT);
+  lblPaulaVol->setSize(labelWidth, LABEL_HEIGHT);
   lblPaulaVol->setAlignment(gcn::Graphics::RIGHT);
   sldPaulaVol = new gcn::Slider(0, 100);
   sldPaulaVol->setSize(160, SLIDER_HEIGHT);
@@ -424,12 +439,12 @@
 {
   helptext.clear();
   helptext.push_back("You can turn on sound emulation with different levels of accuracy and choose between mono and stereo.");
-  helptext.push_back("");
+  helptext.push_back(" ");
   helptext.push_back("The different types of interpolation have different impact on the performance. Play with the settings to find the");
   helptext.push_back("type you like most. You may need headphones to really hear the differences between the interpolations.");
-  helptext.push_back("");
+  helptext.push_back(" ");
   helptext.push_back("With \"Filter\", you can select the type of the Amiga audio filter.");
-  helptext.push_back("");
+  helptext.push_back(" ");
   helptext.push_back("With \"Stereo separation\" and \"Stereo delay\", you can adjust how the left and right audio channels of the Amiga");
   helptext.push_back("are mixed to the left and right channels of your device. A value of 70% for separation and no delay is a good");
   helptext.push_back("start.");
diff -Nru src_93/osdep/gui/SelectFile.cpp src/osdep/gui/SelectFile.cpp
--- src_93/osdep/gui/SelectFile.cpp	2019-01-03 19:49:41.000000000 +0200
+++ src/osdep/gui/SelectFile.cpp	2019-08-10 17:37:32.268039006 +0300
@@ -22,6 +22,9 @@
 #include "gui.h"
 #include "gui_handling.h"
 
+#ifdef ANDROIDSDL
+#include "androidsdl_event.h"
+#endif
 
 #define DIALOG_WIDTH 520
 #define DIALOG_HEIGHT 400
@@ -182,6 +185,19 @@
 };
 static SelectFileActionListener* selectFileActionListener;
 
+#ifdef ANDROID
+class EditFilePathActionListener : public gcn::ActionListener
+{
+  public:
+    void action(const gcn::ActionEvent& actionEvent)
+    {
+       char tmp[MAX_PATH];
+       strncpy(tmp, txtCurrent->getText().c_str(), MAX_PATH - 1);
+       checkfoldername(tmp);
+    }
+};
+static EditFilePathActionListener* editFilePathActionListener;
+#endif
 
 static void InitSelectFile(const char *title)
 {
@@ -209,7 +225,13 @@
   txtCurrent = new gcn::TextField();
   txtCurrent->setSize(DIALOG_WIDTH - 2 * DISTANCE_BORDER - 4, TEXTFIELD_HEIGHT);
   txtCurrent->setPosition(DISTANCE_BORDER, 10);
+#ifdef ANDROID
+  txtCurrent->setEnabled(true);
+  editFilePathActionListener =  new EditFilePathActionListener();
+  txtCurrent->addActionListener(editFilePathActionListener);
+#else
   txtCurrent->setEnabled(false);
+#endif
 
   selectFileActionListener = new SelectFileActionListener();
   fileList = new SelectFileListModel(".");
@@ -228,7 +250,11 @@
 #endif
   scrAreaFiles->setPosition(DISTANCE_BORDER, 10 + TEXTFIELD_HEIGHT + 10);
   scrAreaFiles->setSize(DIALOG_WIDTH - 2 * DISTANCE_BORDER - 4, 272);
+#ifdef ANDROID
+  scrAreaFiles->setScrollbarWidth(30);
+#else
   scrAreaFiles->setScrollbarWidth(20);
+#endif
   scrAreaFiles->setBaseColor(gui_baseCol + 0x202020);
 
   if(createNew)
@@ -273,6 +299,9 @@
   delete lstFiles;
   delete scrAreaFiles;
   delete selectFileActionListener;
+#ifdef ANDROID
+  delete editFilePathActionListener;
+#endif
   delete fileList;
   if(createNew)
   {
@@ -355,7 +384,11 @@
       //-------------------------------------------------
       // Send event to guichan/guisan-controls
       //-------------------------------------------------
-      gui_input->pushInput(event);
+#ifdef ANDROIDSDL
+        androidsdl_event(event, gui_input);
+#else
+        gui_input->pushInput(event);
+#endif
     }
 
     // Now we let the Gui object perform its logic.
diff -Nru src_93/osdep/gui/SelectFolder.cpp src/osdep/gui/SelectFolder.cpp
--- src_93/osdep/gui/SelectFolder.cpp	2019-01-03 19:49:41.000000000 +0200
+++ src/osdep/gui/SelectFolder.cpp	2019-08-10 17:37:32.268039006 +0300
@@ -20,10 +20,14 @@
 #include "uae.h"
 #include "gui_handling.h"
 
+#ifdef ANDROIDSDL
+#include "androidsdl_event.h"
+#endif
 
 #define DIALOG_WIDTH 520
 #define DIALOG_HEIGHT 400
 
+std::string volName;
 static bool dialogResult = false;
 static bool dialogFinished = false;
 static char workingDir[MAX_PATH];
@@ -111,11 +115,25 @@
       strncpy(foldername, workingDir, MAX_PATH - 1);
       strncat(foldername, "/", MAX_PATH - 1);
       strncat(foldername, dirList.getElementAt(selected_item).c_str(), MAX_PATH - 1);
+      volName = dirList.getElementAt(selected_item).c_str();
       checkfoldername(foldername);
     }
 };
 static ListBoxActionListener* listBoxActionListener;
 
+#ifdef ANDROID
+class EditDirPathActionListener : public gcn::ActionListener
+{
+  public:
+    void action(const gcn::ActionEvent& actionEvent)
+    {
+       char tmp[MAX_PATH];
+       strncpy(tmp, txtCurrent->getText().c_str(), MAX_PATH - 1);
+       checkfoldername(tmp);
+    }
+};
+static EditDirPathActionListener* editDirPathActionListener;
+#endif
 
 static void InitSelectFolder(const char *title)
 {
@@ -143,7 +161,13 @@
   txtCurrent = new gcn::TextField();
   txtCurrent->setSize(DIALOG_WIDTH - 2 * DISTANCE_BORDER - 4, TEXTFIELD_HEIGHT);
   txtCurrent->setPosition(DISTANCE_BORDER, 10);
+#ifdef ANDROID
+  txtCurrent->setEnabled(true);
+  editDirPathActionListener = new EditDirPathActionListener();
+  txtCurrent->addActionListener(editDirPathActionListener);
+#else
   txtCurrent->setEnabled(false);
+#endif
 
   listBoxActionListener = new ListBoxActionListener();
   
@@ -161,7 +185,11 @@
 #endif
   scrAreaFolders->setPosition(DISTANCE_BORDER, 10 + TEXTFIELD_HEIGHT + 10);
   scrAreaFolders->setSize(DIALOG_WIDTH - 2 * DISTANCE_BORDER - 4, 272);
+#ifdef ANDROID
+  scrAreaFolders->setScrollbarWidth(30);
+#else
   scrAreaFolders->setScrollbarWidth(20);
+#endif
   scrAreaFolders->setBaseColor(gui_baseCol + 0x202020);
   
   wndSelectFolder->add(cmdOK);
@@ -190,7 +218,9 @@
   delete lstFolders;
   delete scrAreaFolders;
   delete listBoxActionListener;
-  
+#ifdef ANDROID
+  delete editDirPathActionListener;
+#endif
   delete wndSelectFolder;
 }
 
@@ -256,7 +286,11 @@
       //-------------------------------------------------
       // Send event to guichan/guisan-controls
       //-------------------------------------------------
-      gui_input->pushInput(event);
+#ifdef ANDROIDSDL
+        androidsdl_event(event, gui_input);
+#else
+        gui_input->pushInput(event);
+#endif
     }
 
     // Now we let the Gui object perform its logic.
diff -Nru src_93/osdep/gui/ShowHelp.cpp src/osdep/gui/ShowHelp.cpp
--- src_93/osdep/gui/ShowHelp.cpp	2019-01-03 19:49:41.000000000 +0200
+++ src/osdep/gui/ShowHelp.cpp	2019-08-10 17:37:32.268039006 +0300
@@ -21,6 +21,9 @@
 #include "gui_handling.h"
 #include "GenericListModel.h"
 
+#ifdef ANDROIDSDL
+#include "androidsdl_event.h"
+#endif
 
 #define DIALOG_WIDTH 760
 #define DIALOG_HEIGHT 420
@@ -143,7 +146,11 @@
       //-------------------------------------------------
       // Send event to guichan/guisan-controls
       //-------------------------------------------------
-      gui_input->pushInput(event);
+#ifdef ANDROIDSDL
+        androidsdl_event(event, gui_input);
+#else
+        gui_input->pushInput(event);
+#endif
     }
 
     // Now we let the Gui object perform its logic.
diff -Nru src_93/osdep/gui/ShowMessage.cpp src/osdep/gui/ShowMessage.cpp
--- src_93/osdep/gui/ShowMessage.cpp	2019-01-03 19:49:41.000000000 +0200
+++ src/osdep/gui/ShowMessage.cpp	2019-08-10 17:37:32.272038876 +0300
@@ -20,6 +20,9 @@
 #include "gui.h"
 #include "gui_handling.h"
 
+#ifdef ANDROIDSDL
+#include "androidsdl_event.h"
+#endif
 
 #define DIALOG_WIDTH 340
 #define DIALOG_HEIGHT 140
@@ -148,7 +151,11 @@
       //-------------------------------------------------
       // Send event to guichan/guisan-controls
       //-------------------------------------------------
-      gui_input->pushInput(event);
+#ifdef ANDROIDSDL
+        androidsdl_event(event, gui_input);
+#else
+        gui_input->pushInput(event);
+#endif
     }
 
     // Now we let the Gui object perform its logic.
diff -Nru src_93/osdep/gui/UaeDropDown.cpp src/osdep/gui/UaeDropDown.cpp
--- src_93/osdep/gui/UaeDropDown.cpp	2019-01-03 19:49:41.000000000 +0200
+++ src/osdep/gui/UaeDropDown.cpp	2019-08-10 17:37:32.272038876 +0300
@@ -60,8 +60,11 @@
     mPreferUp = false;
     mFoldedUpY = -1;
     adjustHeight();
-
+#ifdef ANDROID
+    mScrollArea->setScrollbarWidth(30);
+#else
     mScrollArea->setScrollbarWidth(20);
+#endif
   }
 
   UaeDropDown::~UaeDropDown()
diff -Nru src_93/osdep/pandora.cpp src/osdep/pandora.cpp
--- src_93/osdep/pandora.cpp	2019-08-10 17:34:49.000000000 +0300
+++ src/osdep/pandora.cpp	2019-08-10 17:37:32.272038876 +0300
@@ -82,6 +82,39 @@
 
 	p->picasso96_modeflags = RGBFF_CLUT | RGBFF_R5G6B5 | RGBFF_R8G8B8A8;
 	
+#ifdef ANDROIDSDL
+	p->onScreen = 1;
+	p->onScreen_textinput = 1;
+	p->onScreen_dpad = 1;
+	p->onScreen_button1 = 1;
+	p->onScreen_button2 = 1;
+	p->onScreen_button3 = 1;
+	p->onScreen_button4 = 1;
+	p->onScreen_button5 = 0;
+	p->onScreen_button6 = 0;
+	p->custom_position = 0;
+	p->pos_x_textinput = 0;
+	p->pos_y_textinput = 0;
+	p->pos_x_dpad = 4;
+	p->pos_y_dpad = 215;
+	p->pos_x_button1 = 430;
+	p->pos_y_button1 = 286;
+	p->pos_x_button2 = 378;
+	p->pos_y_button2 = 286;
+	p->pos_x_button3 = 430;
+	p->pos_y_button3 = 214;
+	p->pos_x_button4 = 378;
+	p->pos_y_button4 = 214;
+	p->pos_x_button5 = 430;
+	p->pos_y_button5 = 142;
+	p->pos_x_button6 = 378;
+	p->pos_y_button6 = 142;
+	p->extfilter = 1;
+	p->quickSwitch = 0;
+	p->floatingJoystick = 0;
+	p->disableMenuVKeyb = 0;
+#endif
+	
 	p->cr[0].index = 0;
 	p->cr[0].horiz = -1;
 	p->cr[0].vert = -1;
@@ -137,6 +170,36 @@
 {
   cfgfile_write (f, "pandora.cpu_speed", "%d", p->pandora_cpu_speed);
   cfgfile_write (f, "pandora.tap_delay", "%d", p->pandora_tapDelay);
+#ifdef ANDROIDSDL
+  cfgfile_write (f, "pandora.onscreen", "%d", p->onScreen);
+  cfgfile_write (f, "pandora.onscreen_textinput", "%d", p->onScreen_textinput);
+  cfgfile_write (f, "pandora.onscreen_dpad", "%d", p->onScreen_dpad);
+  cfgfile_write (f, "pandora.onscreen_button1", "%d", p->onScreen_button1);
+  cfgfile_write (f, "pandora.onscreen_button2", "%d", p->onScreen_button2);
+  cfgfile_write (f, "pandora.onscreen_button3", "%d", p->onScreen_button3);
+  cfgfile_write (f, "pandora.onscreen_button4", "%d", p->onScreen_button4);
+  cfgfile_write (f, "pandora.onscreen_button5", "%d", p->onScreen_button5);
+  cfgfile_write (f, "pandora.onscreen_button6", "%d", p->onScreen_button6);
+  cfgfile_write (f, "pandora.custom_position", "%d", p->custom_position);
+  cfgfile_write (f, "pandora.pos_x_textinput", "%d", p->pos_x_textinput);
+  cfgfile_write (f, "pandora.pos_y_textinput", "%d", p->pos_y_textinput);
+  cfgfile_write (f, "pandora.pos_x_dpad", "%d", p->pos_x_dpad);
+  cfgfile_write (f, "pandora.pos_y_dpad", "%d", p->pos_y_dpad);
+  cfgfile_write (f, "pandora.pos_x_button1", "%d", p->pos_x_button1);
+  cfgfile_write (f, "pandora.pos_y_button1", "%d", p->pos_y_button1);
+  cfgfile_write (f, "pandora.pos_x_button2", "%d", p->pos_x_button2);
+  cfgfile_write (f, "pandora.pos_y_button2", "%d", p->pos_y_button2);
+  cfgfile_write (f, "pandora.pos_x_button3", "%d", p->pos_x_button3);
+  cfgfile_write (f, "pandora.pos_y_button3", "%d", p->pos_y_button3);
+  cfgfile_write (f, "pandora.pos_x_button4", "%d", p->pos_x_button4);
+  cfgfile_write (f, "pandora.pos_y_button4", "%d", p->pos_y_button4);
+  cfgfile_write (f, "pandora.pos_x_button5", "%d", p->pos_x_button5);
+  cfgfile_write (f, "pandora.pos_y_button5", "%d", p->pos_y_button5);
+  cfgfile_write (f, "pandora.pos_x_button6", "%d", p->pos_x_button6);
+  cfgfile_write (f, "pandora.pos_y_button6", "%d", p->pos_y_button6);
+  cfgfile_write (f, "pandora.floating_joystick", "%d", p->floatingJoystick);
+  cfgfile_write (f, "pandora.disable_menu_vkeyb", "%d", p->disableMenuVKeyb);
+#endif
 }
 
 
@@ -144,6 +207,36 @@
 {
   int result = (cfgfile_intval (option, value, "cpu_speed", &p->pandora_cpu_speed, 1)
     || cfgfile_intval (option, value, "tap_delay", &p->pandora_tapDelay, 1)
+#ifdef ANDROIDSDL
+    || cfgfile_intval (option, value, "onscreen", &p->onScreen, 1)
+    || cfgfile_intval (option, value, "onscreen_textinput", &p->onScreen_textinput, 1)
+    || cfgfile_intval (option, value, "onscreen_dpad", &p->onScreen_dpad, 1)
+    || cfgfile_intval (option, value, "onscreen_button1", &p->onScreen_button1, 1)
+    || cfgfile_intval (option, value, "onscreen_button2", &p->onScreen_button2, 1)
+    || cfgfile_intval (option, value, "onscreen_button3", &p->onScreen_button3, 1)
+    || cfgfile_intval (option, value, "onscreen_button4", &p->onScreen_button4, 1)
+    || cfgfile_intval (option, value, "onscreen_button5", &p->onScreen_button5, 1)
+    || cfgfile_intval (option, value, "onscreen_button6", &p->onScreen_button6, 1)
+    || cfgfile_intval (option, value, "custom_position", &p->custom_position, 1)
+    || cfgfile_intval (option, value, "pos_x_textinput", &p->pos_x_textinput, 1)
+    || cfgfile_intval (option, value, "pos_y_textinput", &p->pos_y_textinput, 1)
+    || cfgfile_intval (option, value, "pos_x_dpad", &p->pos_x_dpad, 1)
+    || cfgfile_intval (option, value, "pos_y_dpad", &p->pos_y_dpad, 1)
+    || cfgfile_intval (option, value, "pos_x_button1", &p->pos_x_button1, 1)
+    || cfgfile_intval (option, value, "pos_y_button1", &p->pos_y_button1, 1)
+    || cfgfile_intval (option, value, "pos_x_button2", &p->pos_x_button2, 1)
+    || cfgfile_intval (option, value, "pos_y_button2", &p->pos_y_button2, 1)
+    || cfgfile_intval (option, value, "pos_x_button3", &p->pos_x_button3, 1)
+    || cfgfile_intval (option, value, "pos_y_button3", &p->pos_y_button3, 1)
+    || cfgfile_intval (option, value, "pos_x_button4", &p->pos_x_button4, 1)
+    || cfgfile_intval (option, value, "pos_y_button4", &p->pos_y_button4, 1)
+    || cfgfile_intval (option, value, "pos_x_button5", &p->pos_x_button5, 1)
+    || cfgfile_intval (option, value, "pos_y_button5", &p->pos_y_button5, 1)
+    || cfgfile_intval (option, value, "pos_x_button6", &p->pos_x_button6, 1)
+    || cfgfile_intval (option, value, "pos_y_button6", &p->pos_y_button6, 1)
+    || cfgfile_intval (option, value, "floating_joystick", &p->floatingJoystick, 1)
+    || cfgfile_intval (option, value, "disable_menu_vkeyb", &p->disableMenuVKeyb, 1)
+#endif
     );
   if(!result) {
     result = cfgfile_intval (option, value, "move_y", &p->gfx_monitor.gfx_size.y, 1); // For compatibility only
@@ -168,8 +261,11 @@
 static bool handle_internal_functions(int sdlkeycode, int sdlmodifier)
 {
   int i;
-  
+#ifdef ANDROIDSDL
+  if (sdlkeycode == SDLK_F12) { // Select key
+#else
   if (sdlkeycode == SDLK_LCTRL) { // Select key
+#endif
     inputdevice_add_inputcode (AKS_ENTERGUI, 1, NULL);
     return true;
   }
@@ -458,8 +554,79 @@
 				  case SDLK_LSHIFT: // Shift key
             inputdevice_do_keyboard(AK_LSH, 1);
             break;
-            
+  #ifdef ANDROID
+		    case SDLK_LCTRL:
+                        inputdevice_do_keyboard(AK_CTRL, 1);
+                        break;
+		    case SDLK_RSHIFT:
+                        inputdevice_do_keyboard(AK_RSH, 1);
+                        break;
+		    case SDLK_LALT:
+                        inputdevice_do_keyboard(AK_LALT, 1);
+                        break;
+		    case SDLK_RALT:
+                        inputdevice_do_keyboard(AK_RALT, 1);
+                        break;
+		    case SDLK_LMETA:
+                        inputdevice_do_keyboard(AK_LAMI, 1);
+                        break;
+		    case SDLK_RMETA:
+                        inputdevice_do_keyboard(AK_RAMI, 1);
+                        break;
+		    case SDLK_CAPSLOCK:
+                        inputdevice_do_keyboard(AK_CAPSLOCK, 1);
+                        break;
+		    case SDLK_INSERT:
+                        inputdevice_do_keyboard(AK_HELP, 1);
+                        break;
+		    case SDLK_KP_DIVIDE:
+                        inputdevice_do_keyboard(AK_NPDIV, 1);
+                        break;
+		    case SDLK_KP_MINUS:
+                        inputdevice_do_keyboard(AK_NPSUB, 1);
+                        break;
+		    case SDLK_KP_ENTER:
+                        inputdevice_do_keyboard(AK_ENT, 1);
+                        break;
+		    case SDLK_KP_PERIOD:
+                        inputdevice_do_keyboard(AK_NPDEL, 1);
+                        break;
+		    case SDLK_KP0:
+                        inputdevice_do_keyboard(AK_NP0, 1);
+                        break;
+		    case SDLK_KP1:
+                        inputdevice_do_keyboard(AK_NP1, 1);
+                        break;
+		    case SDLK_KP2:
+                        inputdevice_do_keyboard(AK_NP2, 1);
+                        break;
+		    case SDLK_KP3:
+                        inputdevice_do_keyboard(AK_NP3, 1);
+                        break;
+		    case SDLK_KP4:
+                        inputdevice_do_keyboard(AK_NP4, 1);
+                        break;
+		    case SDLK_KP5:
+                        inputdevice_do_keyboard(AK_NP5, 1);
+                        break;
+		    case SDLK_KP6:
+                        inputdevice_do_keyboard(AK_NP6, 1);
+                        break;
+		    case SDLK_KP7:
+                        inputdevice_do_keyboard(AK_NP7, 1);
+                        break;
+		    case SDLK_KP8:
+                        inputdevice_do_keyboard(AK_NP8, 1);
+                        break;
+		    case SDLK_KP9:
+                        inputdevice_do_keyboard(AK_NP9, 1);
+                        break;
+#endif           
+#ifdef ANDROIDSDL
+				  case SDLK_F13: // Left shoulder button
+#else
 				  case SDLK_RSHIFT: // Left shoulder button
+#endif
 				  case SDLK_RCTRL:  // Right shoulder button
   					if(currprefs.input_tablet > TABLET_OFF) {
   					  // Holding left or right shoulder button -> stylus does right mousebutton
@@ -489,14 +656,89 @@
   		    continue;
 
   	    switch(rEvent.key.keysym.sym) {
+#ifdef ANDROIDSDL
+  		    case SDLK_F12: // Select key
+#else
   		    case SDLK_LCTRL: // Select key
+#endif
   		      break;
 
 				  case SDLK_LSHIFT: // Shift key
             inputdevice_do_keyboard(AK_LSH, 0);
             break;
-            
+#ifdef ANDROID
+		    case SDLK_LCTRL:
+                        inputdevice_do_keyboard(AK_CTRL, 0);
+                        break;
+		    case SDLK_RSHIFT:
+                        inputdevice_do_keyboard(AK_RSH, 0);
+                        break;
+		    case SDLK_LALT:
+                        inputdevice_do_keyboard(AK_LALT, 0);
+                        break;
+		    case SDLK_RALT:
+                        inputdevice_do_keyboard(AK_RALT, 0);
+                        break;
+		    case SDLK_LMETA:
+                        inputdevice_do_keyboard(AK_LAMI, 0);
+                        break;
+		    case SDLK_RMETA:
+                        inputdevice_do_keyboard(AK_RAMI, 0);
+                        break;
+		    case SDLK_CAPSLOCK:
+                        inputdevice_do_keyboard(AK_CAPSLOCK, 0);
+                        break;
+		    case SDLK_INSERT:
+                        inputdevice_do_keyboard(AK_HELP, 0);
+                        break;
+		    case SDLK_KP_DIVIDE:
+                        inputdevice_do_keyboard(AK_NPDIV, 0);
+                        break;
+		    case SDLK_KP_MINUS:
+                        inputdevice_do_keyboard(AK_NPSUB, 0);
+                        break;
+		    case SDLK_KP_ENTER:
+                        inputdevice_do_keyboard(AK_ENT, 0);
+                        break;
+		    case SDLK_KP_PERIOD:
+                        inputdevice_do_keyboard(AK_NPDEL, 0);
+                        break;
+		    case SDLK_KP0:
+                        inputdevice_do_keyboard(AK_NP0, 0);
+                        break;
+		    case SDLK_KP1:
+                        inputdevice_do_keyboard(AK_NP1, 0);
+                        break;
+		    case SDLK_KP2:
+                        inputdevice_do_keyboard(AK_NP2, 0);
+                        break;
+		    case SDLK_KP3:
+                        inputdevice_do_keyboard(AK_NP3, 0);
+                        break;
+		    case SDLK_KP4:
+                        inputdevice_do_keyboard(AK_NP4, 0);
+                        break;
+		    case SDLK_KP5:
+                        inputdevice_do_keyboard(AK_NP5, 0);
+                        break;
+		    case SDLK_KP6:
+                        inputdevice_do_keyboard(AK_NP6, 0);
+                        break;
+		    case SDLK_KP7:
+                        inputdevice_do_keyboard(AK_NP7, 0);
+                        break;
+		    case SDLK_KP8:
+                        inputdevice_do_keyboard(AK_NP8, 0);
+                        break;
+		    case SDLK_KP9:
+                        inputdevice_do_keyboard(AK_NP9, 0);
+                        break;
+#endif           
+#ifdef ANDROIDSDL
+				  case SDLK_F13: // Left shoulder button
+#else
 				  case SDLK_RSHIFT: // Left shoulder button
+#endif
 				  case SDLK_RCTRL:  // Right shoulder button
   					if(currprefs.input_tablet > TABLET_OFF) {
   					  // Release left or right shoulder button -> stylus does left mousebutton
diff -Nru src_93/osdep/pandora_gfx.cpp src/osdep/pandora_gfx.cpp
--- src_93/osdep/pandora_gfx.cpp	2019-08-10 17:34:49.000000000 +0300
+++ src/osdep/pandora_gfx.cpp	2019-08-10 17:37:32.272038876 +0300
@@ -16,11 +16,13 @@
 #include <png.h>
 #include <SDL.h>
 #include <SDL/SDL_image.h>
+#ifndef ANDROID
 #include <SDL/SDL_gfxPrimitives.h>
+#endif
 #include <SDL/SDL_ttf.h>
 
 #ifdef ANDROIDSDL
-#include <android/log.h>
+#include <SDL_screenkeyboard.h>
 #endif
 
 #include <linux/fb.h>
@@ -42,9 +44,15 @@
 static uae_u32 last_synctime;
 
 /* Possible screen modes (x and y resolutions) */
+#ifdef ANDROID
+#define MAX_SCREEN_MODES 11
+static int x_size_table[MAX_SCREEN_MODES] = { 640, 640, 720, 800, 800, 960, 1024, 1024, 1280, 1280, 1920 };
+static int y_size_table[MAX_SCREEN_MODES] = { 400, 480, 400, 480, 600, 540,  768,  600,  720,  800, 1080 };
+#else
 #define MAX_SCREEN_MODES 6
 static int x_size_table[MAX_SCREEN_MODES] = { 640, 640, 800, 1024, 1152, 1280 };
 static int y_size_table[MAX_SCREEN_MODES] = { 400, 480, 480,  768,  864,  960 };
+#endif
 
 static int red_bits, green_bits, blue_bits;
 static int red_shift, green_shift, blue_shift;
@@ -180,6 +188,70 @@
   return pandWidth;
 }
 
+#ifdef ANDROIDSDL
+void update_onscreen()
+{
+	SDL_ANDROID_SetScreenKeyboardFloatingJoystick(changed_prefs.floatingJoystick);
+	if (changed_prefs.onScreen==0)
+	{
+	  SDL_ANDROID_SetScreenKeyboardShown(0);
+	}
+	else
+	{
+	  SDL_ANDROID_SetScreenKeyboardShown(1);
+	    SDL_Rect pos_textinput, pos_dpad, pos_button1, pos_button2, pos_button3, pos_button4, pos_button5, pos_button6;
+	    pos_textinput.x = changed_prefs.pos_x_textinput*(SDL_ListModes(NULL, 0)[0]->w/(float)480);
+	    pos_textinput.y = changed_prefs.pos_y_textinput*(SDL_ListModes(NULL, 0)[0]->h/(float)360);
+	    pos_textinput.h=SDL_ListModes(NULL, 0)[0]->h / (float)10;
+	    pos_textinput.w=pos_textinput.h;
+	    SDL_ANDROID_SetScreenKeyboardButtonPos(SDL_ANDROID_SCREENKEYBOARD_BUTTON_TEXT, &pos_textinput);
+	    pos_dpad.x = changed_prefs.pos_x_dpad*(SDL_ListModes(NULL, 0)[0]->w/(float)480);
+	    pos_dpad.y = changed_prefs.pos_y_dpad*(SDL_ListModes(NULL, 0)[0]->h/(float)360);
+	    pos_dpad.h=SDL_ListModes(NULL, 0)[0]->h / (float)2.5;
+	    pos_dpad.w=pos_dpad.h;
+	    SDL_ANDROID_SetScreenKeyboardButtonPos(SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD, &pos_dpad);
+	    pos_button1.x = changed_prefs.pos_x_button1*(SDL_ListModes(NULL, 0)[0]->w/(float)480);
+	    pos_button1.y = changed_prefs.pos_y_button1*(SDL_ListModes(NULL, 0)[0]->h/(float)360);
+	    pos_button1.h=SDL_ListModes(NULL, 0)[0]->h / (float)5;
+	    pos_button1.w=pos_button1.h;
+	    SDL_ANDROID_SetScreenKeyboardButtonPos(SDL_ANDROID_SCREENKEYBOARD_BUTTON_0, &pos_button1);
+	    pos_button2.x = changed_prefs.pos_x_button2*(SDL_ListModes(NULL, 0)[0]->w/(float)480);
+	    pos_button2.y = changed_prefs.pos_y_button2*(SDL_ListModes(NULL, 0)[0]->h/(float)360);
+	    pos_button2.h=SDL_ListModes(NULL, 0)[0]->h / (float)5;
+	    pos_button2.w=pos_button2.h;
+	    SDL_ANDROID_SetScreenKeyboardButtonPos(SDL_ANDROID_SCREENKEYBOARD_BUTTON_1, &pos_button2);
+	    pos_button3.x = changed_prefs.pos_x_button3*(SDL_ListModes(NULL, 0)[0]->w/(float)480);
+	    pos_button3.y = changed_prefs.pos_y_button3*(SDL_ListModes(NULL, 0)[0]->h/(float)360);
+	    pos_button3.h=SDL_ListModes(NULL, 0)[0]->h / (float)5;
+	    pos_button3.w=pos_button3.h;
+	    SDL_ANDROID_SetScreenKeyboardButtonPos(SDL_ANDROID_SCREENKEYBOARD_BUTTON_2, &pos_button3);
+	    pos_button4.x = changed_prefs.pos_x_button4*(SDL_ListModes(NULL, 0)[0]->w/(float)480);
+	    pos_button4.y = changed_prefs.pos_y_button4*(SDL_ListModes(NULL, 0)[0]->h/(float)360);
+	    pos_button4.h=SDL_ListModes(NULL, 0)[0]->h / (float)5;
+	    pos_button4.w=pos_button4.h;
+	    SDL_ANDROID_SetScreenKeyboardButtonPos(SDL_ANDROID_SCREENKEYBOARD_BUTTON_3, &pos_button4);
+	    pos_button5.x = changed_prefs.pos_x_button5*(SDL_ListModes(NULL, 0)[0]->w/(float)480);
+	    pos_button5.y = changed_prefs.pos_y_button5*(SDL_ListModes(NULL, 0)[0]->h/(float)360);
+	    pos_button5.h=SDL_ListModes(NULL, 0)[0]->h / (float)5;
+	    pos_button5.w=pos_button5.h;
+	    SDL_ANDROID_SetScreenKeyboardButtonPos(SDL_ANDROID_SCREENKEYBOARD_BUTTON_4, &pos_button5);
+	    pos_button6.x = changed_prefs.pos_x_button6*(SDL_ListModes(NULL, 0)[0]->w/(float)480);
+	    pos_button6.y = changed_prefs.pos_y_button6*(SDL_ListModes(NULL, 0)[0]->h/(float)360);
+	    pos_button6.h=SDL_ListModes(NULL, 0)[0]->h / (float)5;
+	    pos_button6.w=pos_button6.h;
+	    SDL_ANDROID_SetScreenKeyboardButtonPos(SDL_ANDROID_SCREENKEYBOARD_BUTTON_5, &pos_button6);
+
+	    SDL_ANDROID_SetScreenKeyboardButtonShown(SDL_ANDROID_SCREENKEYBOARD_BUTTON_TEXT, changed_prefs.onScreen_textinput);
+	    SDL_ANDROID_SetScreenKeyboardButtonShown(SDL_ANDROID_SCREENKEYBOARD_BUTTON_DPAD, changed_prefs.onScreen_dpad);
+	    SDL_ANDROID_SetScreenKeyboardButtonShown(SDL_ANDROID_SCREENKEYBOARD_BUTTON_0, changed_prefs.onScreen_button1);
+	    SDL_ANDROID_SetScreenKeyboardButtonShown(SDL_ANDROID_SCREENKEYBOARD_BUTTON_1, changed_prefs.onScreen_button2);
+	    SDL_ANDROID_SetScreenKeyboardButtonShown(SDL_ANDROID_SCREENKEYBOARD_BUTTON_2, changed_prefs.onScreen_button3);
+	    SDL_ANDROID_SetScreenKeyboardButtonShown(SDL_ANDROID_SCREENKEYBOARD_BUTTON_3, changed_prefs.onScreen_button4);
+	    SDL_ANDROID_SetScreenKeyboardButtonShown(SDL_ANDROID_SCREENKEYBOARD_BUTTON_4, changed_prefs.onScreen_button5);
+	    SDL_ANDROID_SetScreenKeyboardButtonShown(SDL_ANDROID_SCREENKEYBOARD_BUTTON_5, changed_prefs.onScreen_button6);
+	}
+}
+#endif
 
 static void open_screen(struct uae_prefs *p)
 {
@@ -212,8 +284,8 @@
   {
     if(prSDLScreen == NULL || prSDLScreen->w != p->gfx_monitor.gfx_size.width || prSDLScreen->h != p->gfx_monitor.gfx_size.height << p->gfx_vresolution)
     {
-#if !defined(WIN32)
-  	  prSDLScreen = SDL_SetVideoMode(p->gfx_monitor.gfx_size.width, p->gfx_monitor.gfx_size.height << p->gfx_vresolution, 16, SDL_HWSURFACE|SDL_FULLSCREEN|SDL_DOUBLEBUF);
+#ifdef ANDROIDSDL
+  	  prSDLScreen = SDL_SetVideoMode(p->gfx_monitor.gfx_size.width, p->gfx_monitor.gfx_size.height << p->gfx_vresolution, 16, SDL_SWSURFACE);
 #else
   	  prSDLScreen = SDL_SetVideoMode(p->gfx_monitor.gfx_size.width, p->gfx_monitor.gfx_size.height << p->gfx_vresolution, 16, SDL_SWSURFACE|SDL_DOUBLEBUF);
 #endif
@@ -222,7 +294,11 @@
   else
   {
     if(picasso_vidinfo.width != 0 && picasso_vidinfo.height != 0)
+#ifdef ANDROIDSDL
+  	    prSDLScreen = SDL_SetVideoMode(picasso_vidinfo.width, picasso_vidinfo.height, 16, SDL_SWSURFACE|SDL_FULLSCREEN);
+#else
     	prSDLScreen = SDL_SetVideoMode(picasso_vidinfo.width, picasso_vidinfo.height, 16, SDL_HWSURFACE|SDL_FULLSCREEN|SDL_DOUBLEBUF);
+#endif
   }
   if(prSDLScreen != NULL)
   {
@@ -231,6 +307,7 @@
   }
   
   current_vsync_frame = 0;
+
   fbdev = open("/dev/fb0", O_RDWR);
   if(fbdev != -1)
   {
@@ -351,7 +428,6 @@
   }
 }
 
-
 void reset_sync(void)
 {
   wait_for_vsync();
@@ -709,7 +785,7 @@
 #ifdef PICASSO96
 
 
-int picasso_palette (struct MyCLUTEntry *CLUT)
+int picasso_palette (struct MyCLUTEntry *CLUT, uae_u32 *clut)
 {
 	int changed = 0;
 	
diff -Nru src_93/osdep/sigsegv_handler.cpp src/osdep/sigsegv_handler.cpp
--- src_93/osdep/sigsegv_handler.cpp	2019-08-10 17:34:49.000000000 +0300
+++ src/osdep/sigsegv_handler.cpp	2019-08-10 17:37:32.272038876 +0300
@@ -39,7 +39,13 @@
 #include <asm/sigcontext.h>
 #include <signal.h>
 #include <dlfcn.h>
+#ifndef ANDROID
 #include <execinfo.h>
+#else
+int backtrace(void**,int){ return 0; }
+char** backtrace_symbols(void* const*,int){return NULL; }
+void backtrace_symbols_fd(void* const*,int,int){} 
+#endif
 #include <SDL.h>
 
 #ifdef JIT
diff -Nru src_93/osdep/sysconfig.h src/osdep/sysconfig.h
--- src_93/osdep/sysconfig.h	2019-08-10 17:28:24.000000000 +0300
+++ src/osdep/sysconfig.h	2019-08-10 17:39:55.407972769 +0300
@@ -553,9 +553,18 @@
 #define _timezone           timezone
 #define _daylight           daylight
 #define _ftime(x)           ftime(x)
-#define _ftelli64(x)        ftello64(x)
-#define _fseeki64(x,y,z)    fseeko64(x,y,z)
+#ifdef ANDROID
+ #define _ftelli64(x)        ftello(x)
+ #define _fseeki64(x,y,z)    fseeko(x,y,z)
+#else
+ #define _ftelli64(x)        ftello64(x)
+ #define _fseeki64(x,y,z)    fseeko64(x,y,z)
+#endif
 #define _wunlink(x)         unlink(x)
 #define _istalnum(x)        isalnum(x)
 
+#ifdef ANDROID
+#define log2l(x)            (log(x)/log(2))
+#endif
+
 #endif /* UAE_SYSCONFIG_H */
diff -Nru src_93/osdep/writelog.cpp src/osdep/writelog.cpp
--- src_93/osdep/writelog.cpp	2019-08-10 13:54:46.000000000 +0300
+++ src/osdep/writelog.cpp	2019-08-10 17:37:32.272038876 +0300
@@ -20,7 +20,7 @@
     va_start (parms, format);
     vsnprintf (buffer, WRITE_LOG_BUF_SIZE-1, format, parms);
     va_end (parms);
-    printf(buffer);
+    printf("%s", buffer);
 }
 
 #ifdef WITH_LOGGING
